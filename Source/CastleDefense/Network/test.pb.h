// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: test.proto
// Protobuf C++ Version: 5.27.3

#ifndef GOOGLE_PROTOBUF_INCLUDED_test_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_test_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5027003
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_test_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_test_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_test_2eproto;
class C_Attack;
struct C_AttackDefaultTypeInternal;
extern C_AttackDefaultTypeInternal _C_Attack_default_instance_;
class C_Chat;
struct C_ChatDefaultTypeInternal;
extern C_ChatDefaultTypeInternal _C_Chat_default_instance_;
class C_Despawn;
struct C_DespawnDefaultTypeInternal;
extern C_DespawnDefaultTypeInternal _C_Despawn_default_instance_;
class C_Login;
struct C_LoginDefaultTypeInternal;
extern C_LoginDefaultTypeInternal _C_Login_default_instance_;
class C_Move;
struct C_MoveDefaultTypeInternal;
extern C_MoveDefaultTypeInternal _C_Move_default_instance_;
class C_Spawn;
struct C_SpawnDefaultTypeInternal;
extern C_SpawnDefaultTypeInternal _C_Spawn_default_instance_;
class Coordiante;
struct CoordianteDefaultTypeInternal;
extern CoordianteDefaultTypeInternal _Coordiante_default_instance_;
class Enemy;
struct EnemyDefaultTypeInternal;
extern EnemyDefaultTypeInternal _Enemy_default_instance_;
class Player;
struct PlayerDefaultTypeInternal;
extern PlayerDefaultTypeInternal _Player_default_instance_;
class Rotation;
struct RotationDefaultTypeInternal;
extern RotationDefaultTypeInternal _Rotation_default_instance_;
class S_Attack;
struct S_AttackDefaultTypeInternal;
extern S_AttackDefaultTypeInternal _S_Attack_default_instance_;
class S_Chat;
struct S_ChatDefaultTypeInternal;
extern S_ChatDefaultTypeInternal _S_Chat_default_instance_;
class S_Despawn;
struct S_DespawnDefaultTypeInternal;
extern S_DespawnDefaultTypeInternal _S_Despawn_default_instance_;
class S_EnemyDespawn;
struct S_EnemyDespawnDefaultTypeInternal;
extern S_EnemyDespawnDefaultTypeInternal _S_EnemyDespawn_default_instance_;
class S_EnemyMove;
struct S_EnemyMoveDefaultTypeInternal;
extern S_EnemyMoveDefaultTypeInternal _S_EnemyMove_default_instance_;
class S_EnemySpawn;
struct S_EnemySpawnDefaultTypeInternal;
extern S_EnemySpawnDefaultTypeInternal _S_EnemySpawn_default_instance_;
class S_Login;
struct S_LoginDefaultTypeInternal;
extern S_LoginDefaultTypeInternal _S_Login_default_instance_;
class S_Move;
struct S_MoveDefaultTypeInternal;
extern S_MoveDefaultTypeInternal _S_Move_default_instance_;
class S_Spawn;
struct S_SpawnDefaultTypeInternal;
extern S_SpawnDefaultTypeInternal _S_Spawn_default_instance_;
class Velocity;
struct VelocityDefaultTypeInternal;
extern VelocityDefaultTypeInternal _Velocity_default_instance_;
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

enum MoveState : int {
  IDLE = 1,
  WALK = 2,
  SPRINT = 3,
  JUMP = 4,
};

bool MoveState_IsValid(int value);
extern const uint32_t MoveState_internal_data_[];
constexpr MoveState MoveState_MIN = static_cast<MoveState>(1);
constexpr MoveState MoveState_MAX = static_cast<MoveState>(4);
constexpr int MoveState_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
MoveState_descriptor();
template <typename T>
const std::string& MoveState_Name(T value) {
  static_assert(std::is_same<T, MoveState>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to MoveState_Name().");
  return MoveState_Name(static_cast<MoveState>(value));
}
template <>
inline const std::string& MoveState_Name(MoveState value) {
  return ::google::protobuf::internal::NameOfDenseEnum<MoveState_descriptor,
                                                 1, 4>(
      static_cast<int>(value));
}
inline bool MoveState_Parse(absl::string_view name, MoveState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MoveState>(
      MoveState_descriptor(), name, value);
}
enum E_TYPE : int {
  Login = 0,
  Spawn = 1,
  Despawn = 2,
  Movement = 3,
  Chat = 4,
  EnemySpawn = 5,
  EnemyDespawn = 6,
  Attack = 7,
  EnemyMovement = 8,
};

bool E_TYPE_IsValid(int value);
extern const uint32_t E_TYPE_internal_data_[];
constexpr E_TYPE E_TYPE_MIN = static_cast<E_TYPE>(0);
constexpr E_TYPE E_TYPE_MAX = static_cast<E_TYPE>(8);
constexpr int E_TYPE_ARRAYSIZE = 8 + 1;
const ::google::protobuf::EnumDescriptor*
E_TYPE_descriptor();
template <typename T>
const std::string& E_TYPE_Name(T value) {
  static_assert(std::is_same<T, E_TYPE>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to E_TYPE_Name().");
  return E_TYPE_Name(static_cast<E_TYPE>(value));
}
template <>
inline const std::string& E_TYPE_Name(E_TYPE value) {
  return ::google::protobuf::internal::NameOfDenseEnum<E_TYPE_descriptor,
                                                 0, 8>(
      static_cast<int>(value));
}
inline bool E_TYPE_Parse(absl::string_view name, E_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<E_TYPE>(
      E_TYPE_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class Velocity final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:Velocity) */ {
 public:
  inline Velocity() : Velocity(nullptr) {}
  ~Velocity() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Velocity(
      ::google::protobuf::internal::ConstantInitialized);

  inline Velocity(const Velocity& from) : Velocity(nullptr, from) {}
  inline Velocity(Velocity&& from) noexcept
      : Velocity(nullptr, std::move(from)) {}
  inline Velocity& operator=(const Velocity& from) {
    CopyFrom(from);
    return *this;
  }
  inline Velocity& operator=(Velocity&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Velocity& default_instance() {
    return *internal_default_instance();
  }
  static inline const Velocity* internal_default_instance() {
    return reinterpret_cast<const Velocity*>(
        &_Velocity_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(Velocity& a, Velocity& b) { a.Swap(&b); }
  inline void Swap(Velocity* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Velocity* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Velocity* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Velocity>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Velocity& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Velocity& from) { Velocity::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Velocity* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "Velocity"; }

 protected:
  explicit Velocity(::google::protobuf::Arena* arena);
  Velocity(::google::protobuf::Arena* arena, const Velocity& from);
  Velocity(::google::protobuf::Arena* arena, Velocity&& from) noexcept
      : Velocity(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // required float x = 1;
  bool has_x() const;
  void clear_x() ;
  float x() const;
  void set_x(float value);

  private:
  float _internal_x() const;
  void _internal_set_x(float value);

  public:
  // required float y = 2;
  bool has_y() const;
  void clear_y() ;
  float y() const;
  void set_y(float value);

  private:
  float _internal_y() const;
  void _internal_set_y(float value);

  public:
  // required float z = 3;
  bool has_z() const;
  void clear_z() ;
  float z() const;
  void set_z(float value);

  private:
  float _internal_z() const;
  void _internal_set_z(float value);

  public:
  // @@protoc_insertion_point(class_scope:Velocity)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Velocity_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Velocity& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    float x_;
    float y_;
    float z_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class S_Login final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:S_Login) */ {
 public:
  inline S_Login() : S_Login(nullptr) {}
  ~S_Login() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR S_Login(
      ::google::protobuf::internal::ConstantInitialized);

  inline S_Login(const S_Login& from) : S_Login(nullptr, from) {}
  inline S_Login(S_Login&& from) noexcept
      : S_Login(nullptr, std::move(from)) {}
  inline S_Login& operator=(const S_Login& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_Login& operator=(S_Login&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_Login& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_Login* internal_default_instance() {
    return reinterpret_cast<const S_Login*>(
        &_S_Login_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(S_Login& a, S_Login& b) { a.Swap(&b); }
  inline void Swap(S_Login* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_Login* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_Login* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<S_Login>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const S_Login& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const S_Login& from) { S_Login::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(S_Login* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "S_Login"; }

 protected:
  explicit S_Login(::google::protobuf::Arena* arena);
  S_Login(::google::protobuf::Arena* arena, const S_Login& from);
  S_Login(::google::protobuf::Arena* arena, S_Login&& from) noexcept
      : S_Login(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBSuccededFieldNumber = 1,
  };
  // required bool bSucceded = 1;
  bool has_bsucceded() const;
  void clear_bsucceded() ;
  bool bsucceded() const;
  void set_bsucceded(bool value);

  private:
  bool _internal_bsucceded() const;
  void _internal_set_bsucceded(bool value);

  public:
  // @@protoc_insertion_point(class_scope:S_Login)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_S_Login_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const S_Login& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    bool bsucceded_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class S_EnemyDespawn final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:S_EnemyDespawn) */ {
 public:
  inline S_EnemyDespawn() : S_EnemyDespawn(nullptr) {}
  ~S_EnemyDespawn() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR S_EnemyDespawn(
      ::google::protobuf::internal::ConstantInitialized);

  inline S_EnemyDespawn(const S_EnemyDespawn& from) : S_EnemyDespawn(nullptr, from) {}
  inline S_EnemyDespawn(S_EnemyDespawn&& from) noexcept
      : S_EnemyDespawn(nullptr, std::move(from)) {}
  inline S_EnemyDespawn& operator=(const S_EnemyDespawn& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_EnemyDespawn& operator=(S_EnemyDespawn&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_EnemyDespawn& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_EnemyDespawn* internal_default_instance() {
    return reinterpret_cast<const S_EnemyDespawn*>(
        &_S_EnemyDespawn_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(S_EnemyDespawn& a, S_EnemyDespawn& b) { a.Swap(&b); }
  inline void Swap(S_EnemyDespawn* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_EnemyDespawn* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_EnemyDespawn* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<S_EnemyDespawn>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const S_EnemyDespawn& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const S_EnemyDespawn& from) { S_EnemyDespawn::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(S_EnemyDespawn* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "S_EnemyDespawn"; }

 protected:
  explicit S_EnemyDespawn(::google::protobuf::Arena* arena);
  S_EnemyDespawn(::google::protobuf::Arena* arena, const S_EnemyDespawn& from);
  S_EnemyDespawn(::google::protobuf::Arena* arena, S_EnemyDespawn&& from) noexcept
      : S_EnemyDespawn(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
  };
  // required int32 id = 1;
  bool has_id() const;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:S_EnemyDespawn)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_S_EnemyDespawn_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const S_EnemyDespawn& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class S_Despawn final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:S_Despawn) */ {
 public:
  inline S_Despawn() : S_Despawn(nullptr) {}
  ~S_Despawn() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR S_Despawn(
      ::google::protobuf::internal::ConstantInitialized);

  inline S_Despawn(const S_Despawn& from) : S_Despawn(nullptr, from) {}
  inline S_Despawn(S_Despawn&& from) noexcept
      : S_Despawn(nullptr, std::move(from)) {}
  inline S_Despawn& operator=(const S_Despawn& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_Despawn& operator=(S_Despawn&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_Despawn& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_Despawn* internal_default_instance() {
    return reinterpret_cast<const S_Despawn*>(
        &_S_Despawn_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(S_Despawn& a, S_Despawn& b) { a.Swap(&b); }
  inline void Swap(S_Despawn* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_Despawn* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_Despawn* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<S_Despawn>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const S_Despawn& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const S_Despawn& from) { S_Despawn::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(S_Despawn* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "S_Despawn"; }

 protected:
  explicit S_Despawn(::google::protobuf::Arena* arena);
  S_Despawn(::google::protobuf::Arena* arena, const S_Despawn& from);
  S_Despawn(::google::protobuf::Arena* arena, S_Despawn&& from) noexcept
      : S_Despawn(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
  };
  // required int32 id = 1;
  bool has_id() const;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:S_Despawn)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_S_Despawn_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const S_Despawn& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class S_Chat final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:S_Chat) */ {
 public:
  inline S_Chat() : S_Chat(nullptr) {}
  ~S_Chat() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR S_Chat(
      ::google::protobuf::internal::ConstantInitialized);

  inline S_Chat(const S_Chat& from) : S_Chat(nullptr, from) {}
  inline S_Chat(S_Chat&& from) noexcept
      : S_Chat(nullptr, std::move(from)) {}
  inline S_Chat& operator=(const S_Chat& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_Chat& operator=(S_Chat&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_Chat& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_Chat* internal_default_instance() {
    return reinterpret_cast<const S_Chat*>(
        &_S_Chat_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(S_Chat& a, S_Chat& b) { a.Swap(&b); }
  inline void Swap(S_Chat* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_Chat* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_Chat* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<S_Chat>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const S_Chat& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const S_Chat& from) { S_Chat::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(S_Chat* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "S_Chat"; }

 protected:
  explicit S_Chat(::google::protobuf::Arena* arena);
  S_Chat(::google::protobuf::Arena* arena, const S_Chat& from);
  S_Chat(::google::protobuf::Arena* arena, S_Chat&& from) noexcept
      : S_Chat(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMsgFieldNumber = 1,
  };
  // required string msg = 1;
  bool has_msg() const;
  void clear_msg() ;
  const std::string& msg() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_msg(Arg_&& arg, Args_... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* value);

  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(
      const std::string& value);
  std::string* _internal_mutable_msg();

  public:
  // @@protoc_insertion_point(class_scope:S_Chat)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      18, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_S_Chat_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const S_Chat& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr msg_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class S_Attack final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:S_Attack) */ {
 public:
  inline S_Attack() : S_Attack(nullptr) {}
  ~S_Attack() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR S_Attack(
      ::google::protobuf::internal::ConstantInitialized);

  inline S_Attack(const S_Attack& from) : S_Attack(nullptr, from) {}
  inline S_Attack(S_Attack&& from) noexcept
      : S_Attack(nullptr, std::move(from)) {}
  inline S_Attack& operator=(const S_Attack& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_Attack& operator=(S_Attack&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_Attack& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_Attack* internal_default_instance() {
    return reinterpret_cast<const S_Attack*>(
        &_S_Attack_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(S_Attack& a, S_Attack& b) { a.Swap(&b); }
  inline void Swap(S_Attack* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_Attack* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_Attack* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<S_Attack>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const S_Attack& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const S_Attack& from) { S_Attack::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(S_Attack* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "S_Attack"; }

 protected:
  explicit S_Attack(::google::protobuf::Arena* arena);
  S_Attack(::google::protobuf::Arena* arena, const S_Attack& from);
  S_Attack(::google::protobuf::Arena* arena, S_Attack&& from) noexcept
      : S_Attack(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTargetFieldNumber = 1,
  };
  // required int32 Target = 1;
  bool has_target() const;
  void clear_target() ;
  ::int32_t target() const;
  void set_target(::int32_t value);

  private:
  ::int32_t _internal_target() const;
  void _internal_set_target(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:S_Attack)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_S_Attack_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const S_Attack& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t target_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class Rotation final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:Rotation) */ {
 public:
  inline Rotation() : Rotation(nullptr) {}
  ~Rotation() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Rotation(
      ::google::protobuf::internal::ConstantInitialized);

  inline Rotation(const Rotation& from) : Rotation(nullptr, from) {}
  inline Rotation(Rotation&& from) noexcept
      : Rotation(nullptr, std::move(from)) {}
  inline Rotation& operator=(const Rotation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rotation& operator=(Rotation&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Rotation& default_instance() {
    return *internal_default_instance();
  }
  static inline const Rotation* internal_default_instance() {
    return reinterpret_cast<const Rotation*>(
        &_Rotation_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(Rotation& a, Rotation& b) { a.Swap(&b); }
  inline void Swap(Rotation* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rotation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Rotation* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Rotation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Rotation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Rotation& from) { Rotation::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Rotation* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "Rotation"; }

 protected:
  explicit Rotation(::google::protobuf::Arena* arena);
  Rotation(::google::protobuf::Arena* arena, const Rotation& from);
  Rotation(::google::protobuf::Arena* arena, Rotation&& from) noexcept
      : Rotation(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // required float x = 1;
  bool has_x() const;
  void clear_x() ;
  float x() const;
  void set_x(float value);

  private:
  float _internal_x() const;
  void _internal_set_x(float value);

  public:
  // required float y = 2;
  bool has_y() const;
  void clear_y() ;
  float y() const;
  void set_y(float value);

  private:
  float _internal_y() const;
  void _internal_set_y(float value);

  public:
  // required float z = 3;
  bool has_z() const;
  void clear_z() ;
  float z() const;
  void set_z(float value);

  private:
  float _internal_z() const;
  void _internal_set_z(float value);

  public:
  // @@protoc_insertion_point(class_scope:Rotation)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Rotation_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Rotation& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    float x_;
    float y_;
    float z_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class Coordiante final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:Coordiante) */ {
 public:
  inline Coordiante() : Coordiante(nullptr) {}
  ~Coordiante() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Coordiante(
      ::google::protobuf::internal::ConstantInitialized);

  inline Coordiante(const Coordiante& from) : Coordiante(nullptr, from) {}
  inline Coordiante(Coordiante&& from) noexcept
      : Coordiante(nullptr, std::move(from)) {}
  inline Coordiante& operator=(const Coordiante& from) {
    CopyFrom(from);
    return *this;
  }
  inline Coordiante& operator=(Coordiante&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Coordiante& default_instance() {
    return *internal_default_instance();
  }
  static inline const Coordiante* internal_default_instance() {
    return reinterpret_cast<const Coordiante*>(
        &_Coordiante_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(Coordiante& a, Coordiante& b) { a.Swap(&b); }
  inline void Swap(Coordiante* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Coordiante* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Coordiante* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Coordiante>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Coordiante& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Coordiante& from) { Coordiante::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Coordiante* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "Coordiante"; }

 protected:
  explicit Coordiante(::google::protobuf::Arena* arena);
  Coordiante(::google::protobuf::Arena* arena, const Coordiante& from);
  Coordiante(::google::protobuf::Arena* arena, Coordiante&& from) noexcept
      : Coordiante(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // required float x = 1;
  bool has_x() const;
  void clear_x() ;
  float x() const;
  void set_x(float value);

  private:
  float _internal_x() const;
  void _internal_set_x(float value);

  public:
  // required float y = 2;
  bool has_y() const;
  void clear_y() ;
  float y() const;
  void set_y(float value);

  private:
  float _internal_y() const;
  void _internal_set_y(float value);

  public:
  // required float z = 3;
  bool has_z() const;
  void clear_z() ;
  float z() const;
  void set_z(float value);

  private:
  float _internal_z() const;
  void _internal_set_z(float value);

  public:
  // @@protoc_insertion_point(class_scope:Coordiante)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Coordiante_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Coordiante& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    float x_;
    float y_;
    float z_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class C_Spawn final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:C_Spawn) */ {
 public:
  inline C_Spawn() : C_Spawn(nullptr) {}
  ~C_Spawn() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR C_Spawn(
      ::google::protobuf::internal::ConstantInitialized);

  inline C_Spawn(const C_Spawn& from) : C_Spawn(nullptr, from) {}
  inline C_Spawn(C_Spawn&& from) noexcept
      : C_Spawn(nullptr, std::move(from)) {}
  inline C_Spawn& operator=(const C_Spawn& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_Spawn& operator=(C_Spawn&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_Spawn& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_Spawn* internal_default_instance() {
    return reinterpret_cast<const C_Spawn*>(
        &_C_Spawn_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(C_Spawn& a, C_Spawn& b) { a.Swap(&b); }
  inline void Swap(C_Spawn* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_Spawn* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_Spawn* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<C_Spawn>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const C_Spawn& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const C_Spawn& from) { C_Spawn::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(C_Spawn* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "C_Spawn"; }

 protected:
  explicit C_Spawn(::google::protobuf::Arena* arena);
  C_Spawn(::google::protobuf::Arena* arena, const C_Spawn& from);
  C_Spawn(::google::protobuf::Arena* arena, C_Spawn&& from) noexcept
      : C_Spawn(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
  };
  // required int32 id = 1;
  bool has_id() const;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:C_Spawn)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_C_Spawn_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const C_Spawn& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class C_Login final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:C_Login) */ {
 public:
  inline C_Login() : C_Login(nullptr) {}
  ~C_Login() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR C_Login(
      ::google::protobuf::internal::ConstantInitialized);

  inline C_Login(const C_Login& from) : C_Login(nullptr, from) {}
  inline C_Login(C_Login&& from) noexcept
      : C_Login(nullptr, std::move(from)) {}
  inline C_Login& operator=(const C_Login& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_Login& operator=(C_Login&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_Login& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_Login* internal_default_instance() {
    return reinterpret_cast<const C_Login*>(
        &_C_Login_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(C_Login& a, C_Login& b) { a.Swap(&b); }
  inline void Swap(C_Login* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_Login* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_Login* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<C_Login>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const C_Login& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const C_Login& from) { C_Login::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(C_Login* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "C_Login"; }

 protected:
  explicit C_Login(::google::protobuf::Arena* arena);
  C_Login(::google::protobuf::Arena* arena, const C_Login& from);
  C_Login(::google::protobuf::Arena* arena, C_Login&& from) noexcept
      : C_Login(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
  };
  // required int32 id = 1;
  bool has_id() const;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:C_Login)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_C_Login_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const C_Login& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class C_Despawn final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:C_Despawn) */ {
 public:
  inline C_Despawn() : C_Despawn(nullptr) {}
  ~C_Despawn() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR C_Despawn(
      ::google::protobuf::internal::ConstantInitialized);

  inline C_Despawn(const C_Despawn& from) : C_Despawn(nullptr, from) {}
  inline C_Despawn(C_Despawn&& from) noexcept
      : C_Despawn(nullptr, std::move(from)) {}
  inline C_Despawn& operator=(const C_Despawn& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_Despawn& operator=(C_Despawn&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_Despawn& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_Despawn* internal_default_instance() {
    return reinterpret_cast<const C_Despawn*>(
        &_C_Despawn_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(C_Despawn& a, C_Despawn& b) { a.Swap(&b); }
  inline void Swap(C_Despawn* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_Despawn* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_Despawn* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<C_Despawn>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const C_Despawn& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const C_Despawn& from) { C_Despawn::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(C_Despawn* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "C_Despawn"; }

 protected:
  explicit C_Despawn(::google::protobuf::Arena* arena);
  C_Despawn(::google::protobuf::Arena* arena, const C_Despawn& from);
  C_Despawn(::google::protobuf::Arena* arena, C_Despawn&& from) noexcept
      : C_Despawn(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
  };
  // required int32 id = 1;
  bool has_id() const;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:C_Despawn)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_C_Despawn_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const C_Despawn& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class C_Chat final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:C_Chat) */ {
 public:
  inline C_Chat() : C_Chat(nullptr) {}
  ~C_Chat() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR C_Chat(
      ::google::protobuf::internal::ConstantInitialized);

  inline C_Chat(const C_Chat& from) : C_Chat(nullptr, from) {}
  inline C_Chat(C_Chat&& from) noexcept
      : C_Chat(nullptr, std::move(from)) {}
  inline C_Chat& operator=(const C_Chat& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_Chat& operator=(C_Chat&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_Chat& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_Chat* internal_default_instance() {
    return reinterpret_cast<const C_Chat*>(
        &_C_Chat_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(C_Chat& a, C_Chat& b) { a.Swap(&b); }
  inline void Swap(C_Chat* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_Chat* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_Chat* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<C_Chat>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const C_Chat& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const C_Chat& from) { C_Chat::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(C_Chat* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "C_Chat"; }

 protected:
  explicit C_Chat(::google::protobuf::Arena* arena);
  C_Chat(::google::protobuf::Arena* arena, const C_Chat& from);
  C_Chat(::google::protobuf::Arena* arena, C_Chat&& from) noexcept
      : C_Chat(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMsgFieldNumber = 1,
  };
  // required string msg = 1;
  bool has_msg() const;
  void clear_msg() ;
  const std::string& msg() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_msg(Arg_&& arg, Args_... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* value);

  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(
      const std::string& value);
  std::string* _internal_mutable_msg();

  public:
  // @@protoc_insertion_point(class_scope:C_Chat)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      18, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_C_Chat_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const C_Chat& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr msg_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class C_Attack final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:C_Attack) */ {
 public:
  inline C_Attack() : C_Attack(nullptr) {}
  ~C_Attack() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR C_Attack(
      ::google::protobuf::internal::ConstantInitialized);

  inline C_Attack(const C_Attack& from) : C_Attack(nullptr, from) {}
  inline C_Attack(C_Attack&& from) noexcept
      : C_Attack(nullptr, std::move(from)) {}
  inline C_Attack& operator=(const C_Attack& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_Attack& operator=(C_Attack&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_Attack& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_Attack* internal_default_instance() {
    return reinterpret_cast<const C_Attack*>(
        &_C_Attack_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(C_Attack& a, C_Attack& b) { a.Swap(&b); }
  inline void Swap(C_Attack* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_Attack* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_Attack* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<C_Attack>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const C_Attack& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const C_Attack& from) { C_Attack::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(C_Attack* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "C_Attack"; }

 protected:
  explicit C_Attack(::google::protobuf::Arena* arena);
  C_Attack(::google::protobuf::Arena* arena, const C_Attack& from);
  C_Attack(::google::protobuf::Arena* arena, C_Attack&& from) noexcept
      : C_Attack(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAttackerFieldNumber = 1,
    kTargetFieldNumber = 2,
  };
  // required int32 Attacker = 1;
  bool has_attacker() const;
  void clear_attacker() ;
  ::int32_t attacker() const;
  void set_attacker(::int32_t value);

  private:
  ::int32_t _internal_attacker() const;
  void _internal_set_attacker(::int32_t value);

  public:
  // required int32 Target = 2;
  bool has_target() const;
  void clear_target() ;
  ::int32_t target() const;
  void set_target(::int32_t value);

  private:
  ::int32_t _internal_target() const;
  void _internal_set_target(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:C_Attack)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_C_Attack_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const C_Attack& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t attacker_;
    ::int32_t target_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class Player final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:Player) */ {
 public:
  inline Player() : Player(nullptr) {}
  ~Player() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Player(
      ::google::protobuf::internal::ConstantInitialized);

  inline Player(const Player& from) : Player(nullptr, from) {}
  inline Player(Player&& from) noexcept
      : Player(nullptr, std::move(from)) {}
  inline Player& operator=(const Player& from) {
    CopyFrom(from);
    return *this;
  }
  inline Player& operator=(Player&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Player& default_instance() {
    return *internal_default_instance();
  }
  static inline const Player* internal_default_instance() {
    return reinterpret_cast<const Player*>(
        &_Player_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(Player& a, Player& b) { a.Swap(&b); }
  inline void Swap(Player* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Player* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Player* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Player>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Player& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Player& from) { Player::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Player* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "Player"; }

 protected:
  explicit Player(::google::protobuf::Arena* arena);
  Player(::google::protobuf::Arena* arena, const Player& from);
  Player(::google::protobuf::Arena* arena, Player&& from) noexcept
      : Player(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCoordFieldNumber = 4,
    kRotFieldNumber = 5,
    kVelFieldNumber = 6,
    kDirFieldNumber = 7,
    kIdFieldNumber = 1,
    kHpFieldNumber = 2,
    kBAttackFieldNumber = 3,
    kMoveStateFieldNumber = 8,
  };
  // required .Coordiante coord = 4;
  bool has_coord() const;
  void clear_coord() ;
  const ::Coordiante& coord() const;
  PROTOBUF_NODISCARD ::Coordiante* release_coord();
  ::Coordiante* mutable_coord();
  void set_allocated_coord(::Coordiante* value);
  void unsafe_arena_set_allocated_coord(::Coordiante* value);
  ::Coordiante* unsafe_arena_release_coord();

  private:
  const ::Coordiante& _internal_coord() const;
  ::Coordiante* _internal_mutable_coord();

  public:
  // required .Rotation rot = 5;
  bool has_rot() const;
  void clear_rot() ;
  const ::Rotation& rot() const;
  PROTOBUF_NODISCARD ::Rotation* release_rot();
  ::Rotation* mutable_rot();
  void set_allocated_rot(::Rotation* value);
  void unsafe_arena_set_allocated_rot(::Rotation* value);
  ::Rotation* unsafe_arena_release_rot();

  private:
  const ::Rotation& _internal_rot() const;
  ::Rotation* _internal_mutable_rot();

  public:
  // required .Velocity vel = 6;
  bool has_vel() const;
  void clear_vel() ;
  const ::Velocity& vel() const;
  PROTOBUF_NODISCARD ::Velocity* release_vel();
  ::Velocity* mutable_vel();
  void set_allocated_vel(::Velocity* value);
  void unsafe_arena_set_allocated_vel(::Velocity* value);
  ::Velocity* unsafe_arena_release_vel();

  private:
  const ::Velocity& _internal_vel() const;
  ::Velocity* _internal_mutable_vel();

  public:
  // required .Coordiante dir = 7;
  bool has_dir() const;
  void clear_dir() ;
  const ::Coordiante& dir() const;
  PROTOBUF_NODISCARD ::Coordiante* release_dir();
  ::Coordiante* mutable_dir();
  void set_allocated_dir(::Coordiante* value);
  void unsafe_arena_set_allocated_dir(::Coordiante* value);
  ::Coordiante* unsafe_arena_release_dir();

  private:
  const ::Coordiante& _internal_dir() const;
  ::Coordiante* _internal_mutable_dir();

  public:
  // required int32 id = 1;
  bool has_id() const;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // required int32 hp = 2;
  bool has_hp() const;
  void clear_hp() ;
  ::int32_t hp() const;
  void set_hp(::int32_t value);

  private:
  ::int32_t _internal_hp() const;
  void _internal_set_hp(::int32_t value);

  public:
  // required bool bAttack = 3;
  bool has_battack() const;
  void clear_battack() ;
  bool battack() const;
  void set_battack(bool value);

  private:
  bool _internal_battack() const;
  void _internal_set_battack(bool value);

  public:
  // required .MoveState moveState = 8;
  bool has_movestate() const;
  void clear_movestate() ;
  ::MoveState movestate() const;
  void set_movestate(::MoveState value);

  private:
  ::MoveState _internal_movestate() const;
  void _internal_set_movestate(::MoveState value);

  public:
  // @@protoc_insertion_point(class_scope:Player)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 8, 5,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Player_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Player& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::Coordiante* coord_;
    ::Rotation* rot_;
    ::Velocity* vel_;
    ::Coordiante* dir_;
    ::int32_t id_;
    ::int32_t hp_;
    bool battack_;
    int movestate_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class Enemy final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:Enemy) */ {
 public:
  inline Enemy() : Enemy(nullptr) {}
  ~Enemy() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Enemy(
      ::google::protobuf::internal::ConstantInitialized);

  inline Enemy(const Enemy& from) : Enemy(nullptr, from) {}
  inline Enemy(Enemy&& from) noexcept
      : Enemy(nullptr, std::move(from)) {}
  inline Enemy& operator=(const Enemy& from) {
    CopyFrom(from);
    return *this;
  }
  inline Enemy& operator=(Enemy&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Enemy& default_instance() {
    return *internal_default_instance();
  }
  static inline const Enemy* internal_default_instance() {
    return reinterpret_cast<const Enemy*>(
        &_Enemy_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(Enemy& a, Enemy& b) { a.Swap(&b); }
  inline void Swap(Enemy* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Enemy* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Enemy* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Enemy>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Enemy& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Enemy& from) { Enemy::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Enemy* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "Enemy"; }

 protected:
  explicit Enemy(::google::protobuf::Arena* arena);
  Enemy(::google::protobuf::Arena* arena, const Enemy& from);
  Enemy(::google::protobuf::Arena* arena, Enemy&& from) noexcept
      : Enemy(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCoordFieldNumber = 3,
    kRotFieldNumber = 4,
    kDirFieldNumber = 5,
    kIdFieldNumber = 1,
    kHpFieldNumber = 2,
    kBNewDestFieldNumber = 7,
    kMoveStateFieldNumber = 6,
  };
  // required .Coordiante coord = 3;
  bool has_coord() const;
  void clear_coord() ;
  const ::Coordiante& coord() const;
  PROTOBUF_NODISCARD ::Coordiante* release_coord();
  ::Coordiante* mutable_coord();
  void set_allocated_coord(::Coordiante* value);
  void unsafe_arena_set_allocated_coord(::Coordiante* value);
  ::Coordiante* unsafe_arena_release_coord();

  private:
  const ::Coordiante& _internal_coord() const;
  ::Coordiante* _internal_mutable_coord();

  public:
  // required .Rotation rot = 4;
  bool has_rot() const;
  void clear_rot() ;
  const ::Rotation& rot() const;
  PROTOBUF_NODISCARD ::Rotation* release_rot();
  ::Rotation* mutable_rot();
  void set_allocated_rot(::Rotation* value);
  void unsafe_arena_set_allocated_rot(::Rotation* value);
  ::Rotation* unsafe_arena_release_rot();

  private:
  const ::Rotation& _internal_rot() const;
  ::Rotation* _internal_mutable_rot();

  public:
  // required .Coordiante dir = 5;
  bool has_dir() const;
  void clear_dir() ;
  const ::Coordiante& dir() const;
  PROTOBUF_NODISCARD ::Coordiante* release_dir();
  ::Coordiante* mutable_dir();
  void set_allocated_dir(::Coordiante* value);
  void unsafe_arena_set_allocated_dir(::Coordiante* value);
  ::Coordiante* unsafe_arena_release_dir();

  private:
  const ::Coordiante& _internal_dir() const;
  ::Coordiante* _internal_mutable_dir();

  public:
  // required int32 id = 1;
  bool has_id() const;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // required int32 hp = 2;
  bool has_hp() const;
  void clear_hp() ;
  ::int32_t hp() const;
  void set_hp(::int32_t value);

  private:
  ::int32_t _internal_hp() const;
  void _internal_set_hp(::int32_t value);

  public:
  // required bool bNewDest = 7;
  bool has_bnewdest() const;
  void clear_bnewdest() ;
  bool bnewdest() const;
  void set_bnewdest(bool value);

  private:
  bool _internal_bnewdest() const;
  void _internal_set_bnewdest(bool value);

  public:
  // required .MoveState moveState = 6;
  bool has_movestate() const;
  void clear_movestate() ;
  ::MoveState movestate() const;
  void set_movestate(::MoveState value);

  private:
  ::MoveState _internal_movestate() const;
  void _internal_set_movestate(::MoveState value);

  public:
  // @@protoc_insertion_point(class_scope:Enemy)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 4,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Enemy_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Enemy& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::Coordiante* coord_;
    ::Rotation* rot_;
    ::Coordiante* dir_;
    ::int32_t id_;
    ::int32_t hp_;
    bool bnewdest_;
    int movestate_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class S_Spawn final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:S_Spawn) */ {
 public:
  inline S_Spawn() : S_Spawn(nullptr) {}
  ~S_Spawn() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR S_Spawn(
      ::google::protobuf::internal::ConstantInitialized);

  inline S_Spawn(const S_Spawn& from) : S_Spawn(nullptr, from) {}
  inline S_Spawn(S_Spawn&& from) noexcept
      : S_Spawn(nullptr, std::move(from)) {}
  inline S_Spawn& operator=(const S_Spawn& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_Spawn& operator=(S_Spawn&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_Spawn& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_Spawn* internal_default_instance() {
    return reinterpret_cast<const S_Spawn*>(
        &_S_Spawn_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(S_Spawn& a, S_Spawn& b) { a.Swap(&b); }
  inline void Swap(S_Spawn* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_Spawn* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_Spawn* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<S_Spawn>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const S_Spawn& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const S_Spawn& from) { S_Spawn::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(S_Spawn* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "S_Spawn"; }

 protected:
  explicit S_Spawn(::google::protobuf::Arena* arena);
  S_Spawn(::google::protobuf::Arena* arena, const S_Spawn& from);
  S_Spawn(::google::protobuf::Arena* arena, S_Spawn&& from) noexcept
      : S_Spawn(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPlayerFieldNumber = 1,
  };
  // repeated .Player player = 1;
  int player_size() const;
  private:
  int _internal_player_size() const;

  public:
  void clear_player() ;
  ::Player* mutable_player(int index);
  ::google::protobuf::RepeatedPtrField<::Player>* mutable_player();

  private:
  const ::google::protobuf::RepeatedPtrField<::Player>& _internal_player() const;
  ::google::protobuf::RepeatedPtrField<::Player>* _internal_mutable_player();
  public:
  const ::Player& player(int index) const;
  ::Player* add_player();
  const ::google::protobuf::RepeatedPtrField<::Player>& player() const;
  // @@protoc_insertion_point(class_scope:S_Spawn)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_S_Spawn_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const S_Spawn& from_msg);
    ::google::protobuf::RepeatedPtrField< ::Player > player_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class S_Move final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:S_Move) */ {
 public:
  inline S_Move() : S_Move(nullptr) {}
  ~S_Move() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR S_Move(
      ::google::protobuf::internal::ConstantInitialized);

  inline S_Move(const S_Move& from) : S_Move(nullptr, from) {}
  inline S_Move(S_Move&& from) noexcept
      : S_Move(nullptr, std::move(from)) {}
  inline S_Move& operator=(const S_Move& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_Move& operator=(S_Move&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_Move& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_Move* internal_default_instance() {
    return reinterpret_cast<const S_Move*>(
        &_S_Move_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(S_Move& a, S_Move& b) { a.Swap(&b); }
  inline void Swap(S_Move* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_Move* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_Move* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<S_Move>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const S_Move& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const S_Move& from) { S_Move::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(S_Move* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "S_Move"; }

 protected:
  explicit S_Move(::google::protobuf::Arena* arena);
  S_Move(::google::protobuf::Arena* arena, const S_Move& from);
  S_Move(::google::protobuf::Arena* arena, S_Move&& from) noexcept
      : S_Move(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPlayerFieldNumber = 1,
  };
  // repeated .Player player = 1;
  int player_size() const;
  private:
  int _internal_player_size() const;

  public:
  void clear_player() ;
  ::Player* mutable_player(int index);
  ::google::protobuf::RepeatedPtrField<::Player>* mutable_player();

  private:
  const ::google::protobuf::RepeatedPtrField<::Player>& _internal_player() const;
  ::google::protobuf::RepeatedPtrField<::Player>* _internal_mutable_player();
  public:
  const ::Player& player(int index) const;
  ::Player* add_player();
  const ::google::protobuf::RepeatedPtrField<::Player>& player() const;
  // @@protoc_insertion_point(class_scope:S_Move)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_S_Move_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const S_Move& from_msg);
    ::google::protobuf::RepeatedPtrField< ::Player > player_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class S_EnemySpawn final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:S_EnemySpawn) */ {
 public:
  inline S_EnemySpawn() : S_EnemySpawn(nullptr) {}
  ~S_EnemySpawn() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR S_EnemySpawn(
      ::google::protobuf::internal::ConstantInitialized);

  inline S_EnemySpawn(const S_EnemySpawn& from) : S_EnemySpawn(nullptr, from) {}
  inline S_EnemySpawn(S_EnemySpawn&& from) noexcept
      : S_EnemySpawn(nullptr, std::move(from)) {}
  inline S_EnemySpawn& operator=(const S_EnemySpawn& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_EnemySpawn& operator=(S_EnemySpawn&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_EnemySpawn& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_EnemySpawn* internal_default_instance() {
    return reinterpret_cast<const S_EnemySpawn*>(
        &_S_EnemySpawn_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(S_EnemySpawn& a, S_EnemySpawn& b) { a.Swap(&b); }
  inline void Swap(S_EnemySpawn* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_EnemySpawn* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_EnemySpawn* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<S_EnemySpawn>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const S_EnemySpawn& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const S_EnemySpawn& from) { S_EnemySpawn::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(S_EnemySpawn* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "S_EnemySpawn"; }

 protected:
  explicit S_EnemySpawn(::google::protobuf::Arena* arena);
  S_EnemySpawn(::google::protobuf::Arena* arena, const S_EnemySpawn& from);
  S_EnemySpawn(::google::protobuf::Arena* arena, S_EnemySpawn&& from) noexcept
      : S_EnemySpawn(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEnemyFieldNumber = 1,
  };
  // repeated .Enemy enemy = 1;
  int enemy_size() const;
  private:
  int _internal_enemy_size() const;

  public:
  void clear_enemy() ;
  ::Enemy* mutable_enemy(int index);
  ::google::protobuf::RepeatedPtrField<::Enemy>* mutable_enemy();

  private:
  const ::google::protobuf::RepeatedPtrField<::Enemy>& _internal_enemy() const;
  ::google::protobuf::RepeatedPtrField<::Enemy>* _internal_mutable_enemy();
  public:
  const ::Enemy& enemy(int index) const;
  ::Enemy* add_enemy();
  const ::google::protobuf::RepeatedPtrField<::Enemy>& enemy() const;
  // @@protoc_insertion_point(class_scope:S_EnemySpawn)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_S_EnemySpawn_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const S_EnemySpawn& from_msg);
    ::google::protobuf::RepeatedPtrField< ::Enemy > enemy_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class S_EnemyMove final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:S_EnemyMove) */ {
 public:
  inline S_EnemyMove() : S_EnemyMove(nullptr) {}
  ~S_EnemyMove() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR S_EnemyMove(
      ::google::protobuf::internal::ConstantInitialized);

  inline S_EnemyMove(const S_EnemyMove& from) : S_EnemyMove(nullptr, from) {}
  inline S_EnemyMove(S_EnemyMove&& from) noexcept
      : S_EnemyMove(nullptr, std::move(from)) {}
  inline S_EnemyMove& operator=(const S_EnemyMove& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_EnemyMove& operator=(S_EnemyMove&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_EnemyMove& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_EnemyMove* internal_default_instance() {
    return reinterpret_cast<const S_EnemyMove*>(
        &_S_EnemyMove_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(S_EnemyMove& a, S_EnemyMove& b) { a.Swap(&b); }
  inline void Swap(S_EnemyMove* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_EnemyMove* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_EnemyMove* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<S_EnemyMove>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const S_EnemyMove& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const S_EnemyMove& from) { S_EnemyMove::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(S_EnemyMove* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "S_EnemyMove"; }

 protected:
  explicit S_EnemyMove(::google::protobuf::Arena* arena);
  S_EnemyMove(::google::protobuf::Arena* arena, const S_EnemyMove& from);
  S_EnemyMove(::google::protobuf::Arena* arena, S_EnemyMove&& from) noexcept
      : S_EnemyMove(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEnemyFieldNumber = 1,
  };
  // repeated .Enemy enemy = 1;
  int enemy_size() const;
  private:
  int _internal_enemy_size() const;

  public:
  void clear_enemy() ;
  ::Enemy* mutable_enemy(int index);
  ::google::protobuf::RepeatedPtrField<::Enemy>* mutable_enemy();

  private:
  const ::google::protobuf::RepeatedPtrField<::Enemy>& _internal_enemy() const;
  ::google::protobuf::RepeatedPtrField<::Enemy>* _internal_mutable_enemy();
  public:
  const ::Enemy& enemy(int index) const;
  ::Enemy* add_enemy();
  const ::google::protobuf::RepeatedPtrField<::Enemy>& enemy() const;
  // @@protoc_insertion_point(class_scope:S_EnemyMove)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_S_EnemyMove_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const S_EnemyMove& from_msg);
    ::google::protobuf::RepeatedPtrField< ::Enemy > enemy_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class C_Move final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:C_Move) */ {
 public:
  inline C_Move() : C_Move(nullptr) {}
  ~C_Move() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR C_Move(
      ::google::protobuf::internal::ConstantInitialized);

  inline C_Move(const C_Move& from) : C_Move(nullptr, from) {}
  inline C_Move(C_Move&& from) noexcept
      : C_Move(nullptr, std::move(from)) {}
  inline C_Move& operator=(const C_Move& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_Move& operator=(C_Move&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_Move& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_Move* internal_default_instance() {
    return reinterpret_cast<const C_Move*>(
        &_C_Move_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(C_Move& a, C_Move& b) { a.Swap(&b); }
  inline void Swap(C_Move* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_Move* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_Move* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<C_Move>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const C_Move& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const C_Move& from) { C_Move::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(C_Move* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "C_Move"; }

 protected:
  explicit C_Move(::google::protobuf::Arena* arena);
  C_Move(::google::protobuf::Arena* arena, const C_Move& from);
  C_Move(::google::protobuf::Arena* arena, C_Move&& from) noexcept
      : C_Move(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPlayerFieldNumber = 1,
  };
  // required .Player player = 1;
  bool has_player() const;
  void clear_player() ;
  const ::Player& player() const;
  PROTOBUF_NODISCARD ::Player* release_player();
  ::Player* mutable_player();
  void set_allocated_player(::Player* value);
  void unsafe_arena_set_allocated_player(::Player* value);
  ::Player* unsafe_arena_release_player();

  private:
  const ::Player& _internal_player() const;
  ::Player* _internal_mutable_player();

  public:
  // @@protoc_insertion_point(class_scope:C_Move)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_C_Move_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const C_Move& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::Player* player_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Coordiante

// required float x = 1;
inline bool Coordiante::has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Coordiante::clear_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float Coordiante::x() const {
  // @@protoc_insertion_point(field_get:Coordiante.x)
  return _internal_x();
}
inline void Coordiante::set_x(float value) {
  _internal_set_x(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:Coordiante.x)
}
inline float Coordiante::_internal_x() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.x_;
}
inline void Coordiante::_internal_set_x(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = value;
}

// required float y = 2;
inline bool Coordiante::has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Coordiante::clear_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float Coordiante::y() const {
  // @@protoc_insertion_point(field_get:Coordiante.y)
  return _internal_y();
}
inline void Coordiante::set_y(float value) {
  _internal_set_y(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:Coordiante.y)
}
inline float Coordiante::_internal_y() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.y_;
}
inline void Coordiante::_internal_set_y(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = value;
}

// required float z = 3;
inline bool Coordiante::has_z() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Coordiante::clear_z() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.z_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float Coordiante::z() const {
  // @@protoc_insertion_point(field_get:Coordiante.z)
  return _internal_z();
}
inline void Coordiante::set_z(float value) {
  _internal_set_z(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:Coordiante.z)
}
inline float Coordiante::_internal_z() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.z_;
}
inline void Coordiante::_internal_set_z(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.z_ = value;
}

// -------------------------------------------------------------------

// Rotation

// required float x = 1;
inline bool Rotation::has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Rotation::clear_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float Rotation::x() const {
  // @@protoc_insertion_point(field_get:Rotation.x)
  return _internal_x();
}
inline void Rotation::set_x(float value) {
  _internal_set_x(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:Rotation.x)
}
inline float Rotation::_internal_x() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.x_;
}
inline void Rotation::_internal_set_x(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = value;
}

// required float y = 2;
inline bool Rotation::has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Rotation::clear_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float Rotation::y() const {
  // @@protoc_insertion_point(field_get:Rotation.y)
  return _internal_y();
}
inline void Rotation::set_y(float value) {
  _internal_set_y(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:Rotation.y)
}
inline float Rotation::_internal_y() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.y_;
}
inline void Rotation::_internal_set_y(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = value;
}

// required float z = 3;
inline bool Rotation::has_z() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Rotation::clear_z() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.z_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float Rotation::z() const {
  // @@protoc_insertion_point(field_get:Rotation.z)
  return _internal_z();
}
inline void Rotation::set_z(float value) {
  _internal_set_z(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:Rotation.z)
}
inline float Rotation::_internal_z() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.z_;
}
inline void Rotation::_internal_set_z(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.z_ = value;
}

// -------------------------------------------------------------------

// Velocity

// required float x = 1;
inline bool Velocity::has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Velocity::clear_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float Velocity::x() const {
  // @@protoc_insertion_point(field_get:Velocity.x)
  return _internal_x();
}
inline void Velocity::set_x(float value) {
  _internal_set_x(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:Velocity.x)
}
inline float Velocity::_internal_x() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.x_;
}
inline void Velocity::_internal_set_x(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = value;
}

// required float y = 2;
inline bool Velocity::has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Velocity::clear_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float Velocity::y() const {
  // @@protoc_insertion_point(field_get:Velocity.y)
  return _internal_y();
}
inline void Velocity::set_y(float value) {
  _internal_set_y(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:Velocity.y)
}
inline float Velocity::_internal_y() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.y_;
}
inline void Velocity::_internal_set_y(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = value;
}

// required float z = 3;
inline bool Velocity::has_z() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Velocity::clear_z() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.z_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float Velocity::z() const {
  // @@protoc_insertion_point(field_get:Velocity.z)
  return _internal_z();
}
inline void Velocity::set_z(float value) {
  _internal_set_z(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:Velocity.z)
}
inline float Velocity::_internal_z() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.z_;
}
inline void Velocity::_internal_set_z(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.z_ = value;
}

// -------------------------------------------------------------------

// Player

// required int32 id = 1;
inline bool Player::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void Player::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t Player::id() const {
  // @@protoc_insertion_point(field_get:Player.id)
  return _internal_id();
}
inline void Player::set_id(::int32_t value) {
  _internal_set_id(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:Player.id)
}
inline ::int32_t Player::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void Player::_internal_set_id(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// required int32 hp = 2;
inline bool Player::has_hp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void Player::clear_hp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hp_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int32_t Player::hp() const {
  // @@protoc_insertion_point(field_get:Player.hp)
  return _internal_hp();
}
inline void Player::set_hp(::int32_t value) {
  _internal_set_hp(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:Player.hp)
}
inline ::int32_t Player::_internal_hp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hp_;
}
inline void Player::_internal_set_hp(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hp_ = value;
}

// required bool bAttack = 3;
inline bool Player::has_battack() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void Player::clear_battack() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.battack_ = false;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool Player::battack() const {
  // @@protoc_insertion_point(field_get:Player.bAttack)
  return _internal_battack();
}
inline void Player::set_battack(bool value) {
  _internal_set_battack(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:Player.bAttack)
}
inline bool Player::_internal_battack() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.battack_;
}
inline void Player::_internal_set_battack(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.battack_ = value;
}

// required .Coordiante coord = 4;
inline bool Player::has_coord() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.coord_ != nullptr);
  return value;
}
inline void Player::clear_coord() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.coord_ != nullptr) _impl_.coord_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::Coordiante& Player::_internal_coord() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::Coordiante* p = _impl_.coord_;
  return p != nullptr ? *p : reinterpret_cast<const ::Coordiante&>(::_Coordiante_default_instance_);
}
inline const ::Coordiante& Player::coord() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Player.coord)
  return _internal_coord();
}
inline void Player::unsafe_arena_set_allocated_coord(::Coordiante* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.coord_);
  }
  _impl_.coord_ = reinterpret_cast<::Coordiante*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Player.coord)
}
inline ::Coordiante* Player::release_coord() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Coordiante* released = _impl_.coord_;
  _impl_.coord_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Coordiante* Player::unsafe_arena_release_coord() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:Player.coord)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Coordiante* temp = _impl_.coord_;
  _impl_.coord_ = nullptr;
  return temp;
}
inline ::Coordiante* Player::_internal_mutable_coord() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.coord_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::Coordiante>(GetArena());
    _impl_.coord_ = reinterpret_cast<::Coordiante*>(p);
  }
  return _impl_.coord_;
}
inline ::Coordiante* Player::mutable_coord() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::Coordiante* _msg = _internal_mutable_coord();
  // @@protoc_insertion_point(field_mutable:Player.coord)
  return _msg;
}
inline void Player::set_allocated_coord(::Coordiante* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.coord_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.coord_ = reinterpret_cast<::Coordiante*>(value);
  // @@protoc_insertion_point(field_set_allocated:Player.coord)
}

// required .Rotation rot = 5;
inline bool Player::has_rot() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rot_ != nullptr);
  return value;
}
inline void Player::clear_rot() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.rot_ != nullptr) _impl_.rot_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::Rotation& Player::_internal_rot() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::Rotation* p = _impl_.rot_;
  return p != nullptr ? *p : reinterpret_cast<const ::Rotation&>(::_Rotation_default_instance_);
}
inline const ::Rotation& Player::rot() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Player.rot)
  return _internal_rot();
}
inline void Player::unsafe_arena_set_allocated_rot(::Rotation* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rot_);
  }
  _impl_.rot_ = reinterpret_cast<::Rotation*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Player.rot)
}
inline ::Rotation* Player::release_rot() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Rotation* released = _impl_.rot_;
  _impl_.rot_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Rotation* Player::unsafe_arena_release_rot() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:Player.rot)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Rotation* temp = _impl_.rot_;
  _impl_.rot_ = nullptr;
  return temp;
}
inline ::Rotation* Player::_internal_mutable_rot() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.rot_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::Rotation>(GetArena());
    _impl_.rot_ = reinterpret_cast<::Rotation*>(p);
  }
  return _impl_.rot_;
}
inline ::Rotation* Player::mutable_rot() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::Rotation* _msg = _internal_mutable_rot();
  // @@protoc_insertion_point(field_mutable:Player.rot)
  return _msg;
}
inline void Player::set_allocated_rot(::Rotation* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.rot_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.rot_ = reinterpret_cast<::Rotation*>(value);
  // @@protoc_insertion_point(field_set_allocated:Player.rot)
}

// required .Velocity vel = 6;
inline bool Player::has_vel() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.vel_ != nullptr);
  return value;
}
inline void Player::clear_vel() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.vel_ != nullptr) _impl_.vel_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::Velocity& Player::_internal_vel() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::Velocity* p = _impl_.vel_;
  return p != nullptr ? *p : reinterpret_cast<const ::Velocity&>(::_Velocity_default_instance_);
}
inline const ::Velocity& Player::vel() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Player.vel)
  return _internal_vel();
}
inline void Player::unsafe_arena_set_allocated_vel(::Velocity* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.vel_);
  }
  _impl_.vel_ = reinterpret_cast<::Velocity*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Player.vel)
}
inline ::Velocity* Player::release_vel() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::Velocity* released = _impl_.vel_;
  _impl_.vel_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Velocity* Player::unsafe_arena_release_vel() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:Player.vel)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::Velocity* temp = _impl_.vel_;
  _impl_.vel_ = nullptr;
  return temp;
}
inline ::Velocity* Player::_internal_mutable_vel() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.vel_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::Velocity>(GetArena());
    _impl_.vel_ = reinterpret_cast<::Velocity*>(p);
  }
  return _impl_.vel_;
}
inline ::Velocity* Player::mutable_vel() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::Velocity* _msg = _internal_mutable_vel();
  // @@protoc_insertion_point(field_mutable:Player.vel)
  return _msg;
}
inline void Player::set_allocated_vel(::Velocity* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.vel_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.vel_ = reinterpret_cast<::Velocity*>(value);
  // @@protoc_insertion_point(field_set_allocated:Player.vel)
}

// required .Coordiante dir = 7;
inline bool Player::has_dir() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dir_ != nullptr);
  return value;
}
inline void Player::clear_dir() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.dir_ != nullptr) _impl_.dir_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::Coordiante& Player::_internal_dir() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::Coordiante* p = _impl_.dir_;
  return p != nullptr ? *p : reinterpret_cast<const ::Coordiante&>(::_Coordiante_default_instance_);
}
inline const ::Coordiante& Player::dir() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Player.dir)
  return _internal_dir();
}
inline void Player::unsafe_arena_set_allocated_dir(::Coordiante* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dir_);
  }
  _impl_.dir_ = reinterpret_cast<::Coordiante*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Player.dir)
}
inline ::Coordiante* Player::release_dir() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::Coordiante* released = _impl_.dir_;
  _impl_.dir_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Coordiante* Player::unsafe_arena_release_dir() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:Player.dir)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::Coordiante* temp = _impl_.dir_;
  _impl_.dir_ = nullptr;
  return temp;
}
inline ::Coordiante* Player::_internal_mutable_dir() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.dir_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::Coordiante>(GetArena());
    _impl_.dir_ = reinterpret_cast<::Coordiante*>(p);
  }
  return _impl_.dir_;
}
inline ::Coordiante* Player::mutable_dir() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::Coordiante* _msg = _internal_mutable_dir();
  // @@protoc_insertion_point(field_mutable:Player.dir)
  return _msg;
}
inline void Player::set_allocated_dir(::Coordiante* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.dir_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.dir_ = reinterpret_cast<::Coordiante*>(value);
  // @@protoc_insertion_point(field_set_allocated:Player.dir)
}

// required .MoveState moveState = 8;
inline bool Player::has_movestate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void Player::clear_movestate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.movestate_ = 1;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::MoveState Player::movestate() const {
  // @@protoc_insertion_point(field_get:Player.moveState)
  return _internal_movestate();
}
inline void Player::set_movestate(::MoveState value) {
  _internal_set_movestate(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:Player.moveState)
}
inline ::MoveState Player::_internal_movestate() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::MoveState>(_impl_.movestate_);
}
inline void Player::_internal_set_movestate(::MoveState value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  assert(::MoveState_IsValid(value));
  _impl_.movestate_ = value;
}

// -------------------------------------------------------------------

// Enemy

// required int32 id = 1;
inline bool Enemy::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void Enemy::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t Enemy::id() const {
  // @@protoc_insertion_point(field_get:Enemy.id)
  return _internal_id();
}
inline void Enemy::set_id(::int32_t value) {
  _internal_set_id(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:Enemy.id)
}
inline ::int32_t Enemy::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void Enemy::_internal_set_id(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// required int32 hp = 2;
inline bool Enemy::has_hp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void Enemy::clear_hp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hp_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t Enemy::hp() const {
  // @@protoc_insertion_point(field_get:Enemy.hp)
  return _internal_hp();
}
inline void Enemy::set_hp(::int32_t value) {
  _internal_set_hp(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:Enemy.hp)
}
inline ::int32_t Enemy::_internal_hp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hp_;
}
inline void Enemy::_internal_set_hp(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hp_ = value;
}

// required .Coordiante coord = 3;
inline bool Enemy::has_coord() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.coord_ != nullptr);
  return value;
}
inline void Enemy::clear_coord() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.coord_ != nullptr) _impl_.coord_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::Coordiante& Enemy::_internal_coord() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::Coordiante* p = _impl_.coord_;
  return p != nullptr ? *p : reinterpret_cast<const ::Coordiante&>(::_Coordiante_default_instance_);
}
inline const ::Coordiante& Enemy::coord() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Enemy.coord)
  return _internal_coord();
}
inline void Enemy::unsafe_arena_set_allocated_coord(::Coordiante* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.coord_);
  }
  _impl_.coord_ = reinterpret_cast<::Coordiante*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Enemy.coord)
}
inline ::Coordiante* Enemy::release_coord() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Coordiante* released = _impl_.coord_;
  _impl_.coord_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Coordiante* Enemy::unsafe_arena_release_coord() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:Enemy.coord)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Coordiante* temp = _impl_.coord_;
  _impl_.coord_ = nullptr;
  return temp;
}
inline ::Coordiante* Enemy::_internal_mutable_coord() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.coord_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::Coordiante>(GetArena());
    _impl_.coord_ = reinterpret_cast<::Coordiante*>(p);
  }
  return _impl_.coord_;
}
inline ::Coordiante* Enemy::mutable_coord() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::Coordiante* _msg = _internal_mutable_coord();
  // @@protoc_insertion_point(field_mutable:Enemy.coord)
  return _msg;
}
inline void Enemy::set_allocated_coord(::Coordiante* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.coord_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.coord_ = reinterpret_cast<::Coordiante*>(value);
  // @@protoc_insertion_point(field_set_allocated:Enemy.coord)
}

// required .Rotation rot = 4;
inline bool Enemy::has_rot() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rot_ != nullptr);
  return value;
}
inline void Enemy::clear_rot() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.rot_ != nullptr) _impl_.rot_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::Rotation& Enemy::_internal_rot() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::Rotation* p = _impl_.rot_;
  return p != nullptr ? *p : reinterpret_cast<const ::Rotation&>(::_Rotation_default_instance_);
}
inline const ::Rotation& Enemy::rot() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Enemy.rot)
  return _internal_rot();
}
inline void Enemy::unsafe_arena_set_allocated_rot(::Rotation* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rot_);
  }
  _impl_.rot_ = reinterpret_cast<::Rotation*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Enemy.rot)
}
inline ::Rotation* Enemy::release_rot() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Rotation* released = _impl_.rot_;
  _impl_.rot_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Rotation* Enemy::unsafe_arena_release_rot() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:Enemy.rot)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Rotation* temp = _impl_.rot_;
  _impl_.rot_ = nullptr;
  return temp;
}
inline ::Rotation* Enemy::_internal_mutable_rot() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.rot_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::Rotation>(GetArena());
    _impl_.rot_ = reinterpret_cast<::Rotation*>(p);
  }
  return _impl_.rot_;
}
inline ::Rotation* Enemy::mutable_rot() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::Rotation* _msg = _internal_mutable_rot();
  // @@protoc_insertion_point(field_mutable:Enemy.rot)
  return _msg;
}
inline void Enemy::set_allocated_rot(::Rotation* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.rot_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.rot_ = reinterpret_cast<::Rotation*>(value);
  // @@protoc_insertion_point(field_set_allocated:Enemy.rot)
}

// required .Coordiante dir = 5;
inline bool Enemy::has_dir() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dir_ != nullptr);
  return value;
}
inline void Enemy::clear_dir() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.dir_ != nullptr) _impl_.dir_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::Coordiante& Enemy::_internal_dir() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::Coordiante* p = _impl_.dir_;
  return p != nullptr ? *p : reinterpret_cast<const ::Coordiante&>(::_Coordiante_default_instance_);
}
inline const ::Coordiante& Enemy::dir() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Enemy.dir)
  return _internal_dir();
}
inline void Enemy::unsafe_arena_set_allocated_dir(::Coordiante* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dir_);
  }
  _impl_.dir_ = reinterpret_cast<::Coordiante*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Enemy.dir)
}
inline ::Coordiante* Enemy::release_dir() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::Coordiante* released = _impl_.dir_;
  _impl_.dir_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Coordiante* Enemy::unsafe_arena_release_dir() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:Enemy.dir)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::Coordiante* temp = _impl_.dir_;
  _impl_.dir_ = nullptr;
  return temp;
}
inline ::Coordiante* Enemy::_internal_mutable_dir() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.dir_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::Coordiante>(GetArena());
    _impl_.dir_ = reinterpret_cast<::Coordiante*>(p);
  }
  return _impl_.dir_;
}
inline ::Coordiante* Enemy::mutable_dir() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::Coordiante* _msg = _internal_mutable_dir();
  // @@protoc_insertion_point(field_mutable:Enemy.dir)
  return _msg;
}
inline void Enemy::set_allocated_dir(::Coordiante* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.dir_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.dir_ = reinterpret_cast<::Coordiante*>(value);
  // @@protoc_insertion_point(field_set_allocated:Enemy.dir)
}

// required .MoveState moveState = 6;
inline bool Enemy::has_movestate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void Enemy::clear_movestate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.movestate_ = 1;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::MoveState Enemy::movestate() const {
  // @@protoc_insertion_point(field_get:Enemy.moveState)
  return _internal_movestate();
}
inline void Enemy::set_movestate(::MoveState value) {
  _internal_set_movestate(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:Enemy.moveState)
}
inline ::MoveState Enemy::_internal_movestate() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::MoveState>(_impl_.movestate_);
}
inline void Enemy::_internal_set_movestate(::MoveState value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  assert(::MoveState_IsValid(value));
  _impl_.movestate_ = value;
}

// required bool bNewDest = 7;
inline bool Enemy::has_bnewdest() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void Enemy::clear_bnewdest() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bnewdest_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool Enemy::bnewdest() const {
  // @@protoc_insertion_point(field_get:Enemy.bNewDest)
  return _internal_bnewdest();
}
inline void Enemy::set_bnewdest(bool value) {
  _internal_set_bnewdest(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:Enemy.bNewDest)
}
inline bool Enemy::_internal_bnewdest() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.bnewdest_;
}
inline void Enemy::_internal_set_bnewdest(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bnewdest_ = value;
}

// -------------------------------------------------------------------

// C_Login

// required int32 id = 1;
inline bool C_Login::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void C_Login::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t C_Login::id() const {
  // @@protoc_insertion_point(field_get:C_Login.id)
  return _internal_id();
}
inline void C_Login::set_id(::int32_t value) {
  _internal_set_id(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:C_Login.id)
}
inline ::int32_t C_Login::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void C_Login::_internal_set_id(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// -------------------------------------------------------------------

// S_Login

// required bool bSucceded = 1;
inline bool S_Login::has_bsucceded() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void S_Login::clear_bsucceded() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bsucceded_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool S_Login::bsucceded() const {
  // @@protoc_insertion_point(field_get:S_Login.bSucceded)
  return _internal_bsucceded();
}
inline void S_Login::set_bsucceded(bool value) {
  _internal_set_bsucceded(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:S_Login.bSucceded)
}
inline bool S_Login::_internal_bsucceded() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.bsucceded_;
}
inline void S_Login::_internal_set_bsucceded(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bsucceded_ = value;
}

// -------------------------------------------------------------------

// C_Spawn

// required int32 id = 1;
inline bool C_Spawn::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void C_Spawn::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t C_Spawn::id() const {
  // @@protoc_insertion_point(field_get:C_Spawn.id)
  return _internal_id();
}
inline void C_Spawn::set_id(::int32_t value) {
  _internal_set_id(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:C_Spawn.id)
}
inline ::int32_t C_Spawn::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void C_Spawn::_internal_set_id(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// -------------------------------------------------------------------

// S_Spawn

// repeated .Player player = 1;
inline int S_Spawn::_internal_player_size() const {
  return _internal_player().size();
}
inline int S_Spawn::player_size() const {
  return _internal_player_size();
}
inline void S_Spawn::clear_player() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_.Clear();
}
inline ::Player* S_Spawn::mutable_player(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:S_Spawn.player)
  return _internal_mutable_player()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::Player>* S_Spawn::mutable_player()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:S_Spawn.player)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_player();
}
inline const ::Player& S_Spawn::player(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:S_Spawn.player)
  return _internal_player().Get(index);
}
inline ::Player* S_Spawn::add_player() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::Player* _add = _internal_mutable_player()->Add();
  // @@protoc_insertion_point(field_add:S_Spawn.player)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::Player>& S_Spawn::player() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:S_Spawn.player)
  return _internal_player();
}
inline const ::google::protobuf::RepeatedPtrField<::Player>&
S_Spawn::_internal_player() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.player_;
}
inline ::google::protobuf::RepeatedPtrField<::Player>*
S_Spawn::_internal_mutable_player() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.player_;
}

// -------------------------------------------------------------------

// C_Despawn

// required int32 id = 1;
inline bool C_Despawn::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void C_Despawn::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t C_Despawn::id() const {
  // @@protoc_insertion_point(field_get:C_Despawn.id)
  return _internal_id();
}
inline void C_Despawn::set_id(::int32_t value) {
  _internal_set_id(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:C_Despawn.id)
}
inline ::int32_t C_Despawn::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void C_Despawn::_internal_set_id(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// -------------------------------------------------------------------

// S_Despawn

// required int32 id = 1;
inline bool S_Despawn::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void S_Despawn::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t S_Despawn::id() const {
  // @@protoc_insertion_point(field_get:S_Despawn.id)
  return _internal_id();
}
inline void S_Despawn::set_id(::int32_t value) {
  _internal_set_id(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:S_Despawn.id)
}
inline ::int32_t S_Despawn::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void S_Despawn::_internal_set_id(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// -------------------------------------------------------------------

// C_Move

// required .Player player = 1;
inline bool C_Move::has_player() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.player_ != nullptr);
  return value;
}
inline void C_Move::clear_player() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.player_ != nullptr) _impl_.player_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::Player& C_Move::_internal_player() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::Player* p = _impl_.player_;
  return p != nullptr ? *p : reinterpret_cast<const ::Player&>(::_Player_default_instance_);
}
inline const ::Player& C_Move::player() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:C_Move.player)
  return _internal_player();
}
inline void C_Move::unsafe_arena_set_allocated_player(::Player* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.player_);
  }
  _impl_.player_ = reinterpret_cast<::Player*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:C_Move.player)
}
inline ::Player* C_Move::release_player() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Player* released = _impl_.player_;
  _impl_.player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Player* C_Move::unsafe_arena_release_player() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:C_Move.player)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
  return temp;
}
inline ::Player* C_Move::_internal_mutable_player() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.player_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::Player>(GetArena());
    _impl_.player_ = reinterpret_cast<::Player*>(p);
  }
  return _impl_.player_;
}
inline ::Player* C_Move::mutable_player() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::Player* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:C_Move.player)
  return _msg;
}
inline void C_Move::set_allocated_player(::Player* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.player_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.player_ = reinterpret_cast<::Player*>(value);
  // @@protoc_insertion_point(field_set_allocated:C_Move.player)
}

// -------------------------------------------------------------------

// S_Move

// repeated .Player player = 1;
inline int S_Move::_internal_player_size() const {
  return _internal_player().size();
}
inline int S_Move::player_size() const {
  return _internal_player_size();
}
inline void S_Move::clear_player() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_.Clear();
}
inline ::Player* S_Move::mutable_player(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:S_Move.player)
  return _internal_mutable_player()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::Player>* S_Move::mutable_player()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:S_Move.player)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_player();
}
inline const ::Player& S_Move::player(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:S_Move.player)
  return _internal_player().Get(index);
}
inline ::Player* S_Move::add_player() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::Player* _add = _internal_mutable_player()->Add();
  // @@protoc_insertion_point(field_add:S_Move.player)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::Player>& S_Move::player() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:S_Move.player)
  return _internal_player();
}
inline const ::google::protobuf::RepeatedPtrField<::Player>&
S_Move::_internal_player() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.player_;
}
inline ::google::protobuf::RepeatedPtrField<::Player>*
S_Move::_internal_mutable_player() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.player_;
}

// -------------------------------------------------------------------

// C_Chat

// required string msg = 1;
inline bool C_Chat::has_msg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void C_Chat::clear_msg() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.msg_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& C_Chat::msg() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:C_Chat.msg)
  return _internal_msg();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void C_Chat::set_msg(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.msg_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:C_Chat.msg)
}
inline std::string* C_Chat::mutable_msg() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:C_Chat.msg)
  return _s;
}
inline const std::string& C_Chat::_internal_msg() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.msg_.Get();
}
inline void C_Chat::_internal_set_msg(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.msg_.Set(value, GetArena());
}
inline std::string* C_Chat::_internal_mutable_msg() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.msg_.Mutable( GetArena());
}
inline std::string* C_Chat::release_msg() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:C_Chat.msg)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.msg_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.msg_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void C_Chat::set_allocated_msg(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.msg_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.msg_.IsDefault()) {
          _impl_.msg_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:C_Chat.msg)
}

// -------------------------------------------------------------------

// S_Chat

// required string msg = 1;
inline bool S_Chat::has_msg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void S_Chat::clear_msg() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.msg_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& S_Chat::msg() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:S_Chat.msg)
  return _internal_msg();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void S_Chat::set_msg(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.msg_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:S_Chat.msg)
}
inline std::string* S_Chat::mutable_msg() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:S_Chat.msg)
  return _s;
}
inline const std::string& S_Chat::_internal_msg() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.msg_.Get();
}
inline void S_Chat::_internal_set_msg(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.msg_.Set(value, GetArena());
}
inline std::string* S_Chat::_internal_mutable_msg() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.msg_.Mutable( GetArena());
}
inline std::string* S_Chat::release_msg() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:S_Chat.msg)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.msg_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.msg_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void S_Chat::set_allocated_msg(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.msg_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.msg_.IsDefault()) {
          _impl_.msg_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:S_Chat.msg)
}

// -------------------------------------------------------------------

// S_EnemySpawn

// repeated .Enemy enemy = 1;
inline int S_EnemySpawn::_internal_enemy_size() const {
  return _internal_enemy().size();
}
inline int S_EnemySpawn::enemy_size() const {
  return _internal_enemy_size();
}
inline void S_EnemySpawn::clear_enemy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enemy_.Clear();
}
inline ::Enemy* S_EnemySpawn::mutable_enemy(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:S_EnemySpawn.enemy)
  return _internal_mutable_enemy()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::Enemy>* S_EnemySpawn::mutable_enemy()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:S_EnemySpawn.enemy)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_enemy();
}
inline const ::Enemy& S_EnemySpawn::enemy(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:S_EnemySpawn.enemy)
  return _internal_enemy().Get(index);
}
inline ::Enemy* S_EnemySpawn::add_enemy() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::Enemy* _add = _internal_mutable_enemy()->Add();
  // @@protoc_insertion_point(field_add:S_EnemySpawn.enemy)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::Enemy>& S_EnemySpawn::enemy() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:S_EnemySpawn.enemy)
  return _internal_enemy();
}
inline const ::google::protobuf::RepeatedPtrField<::Enemy>&
S_EnemySpawn::_internal_enemy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.enemy_;
}
inline ::google::protobuf::RepeatedPtrField<::Enemy>*
S_EnemySpawn::_internal_mutable_enemy() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.enemy_;
}

// -------------------------------------------------------------------

// S_EnemyDespawn

// required int32 id = 1;
inline bool S_EnemyDespawn::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void S_EnemyDespawn::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t S_EnemyDespawn::id() const {
  // @@protoc_insertion_point(field_get:S_EnemyDespawn.id)
  return _internal_id();
}
inline void S_EnemyDespawn::set_id(::int32_t value) {
  _internal_set_id(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:S_EnemyDespawn.id)
}
inline ::int32_t S_EnemyDespawn::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void S_EnemyDespawn::_internal_set_id(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// -------------------------------------------------------------------

// C_Attack

// required int32 Attacker = 1;
inline bool C_Attack::has_attacker() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void C_Attack::clear_attacker() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.attacker_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t C_Attack::attacker() const {
  // @@protoc_insertion_point(field_get:C_Attack.Attacker)
  return _internal_attacker();
}
inline void C_Attack::set_attacker(::int32_t value) {
  _internal_set_attacker(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:C_Attack.Attacker)
}
inline ::int32_t C_Attack::_internal_attacker() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.attacker_;
}
inline void C_Attack::_internal_set_attacker(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.attacker_ = value;
}

// required int32 Target = 2;
inline bool C_Attack::has_target() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void C_Attack::clear_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t C_Attack::target() const {
  // @@protoc_insertion_point(field_get:C_Attack.Target)
  return _internal_target();
}
inline void C_Attack::set_target(::int32_t value) {
  _internal_set_target(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:C_Attack.Target)
}
inline ::int32_t C_Attack::_internal_target() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.target_;
}
inline void C_Attack::_internal_set_target(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_ = value;
}

// -------------------------------------------------------------------

// S_Attack

// required int32 Target = 1;
inline bool S_Attack::has_target() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void S_Attack::clear_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t S_Attack::target() const {
  // @@protoc_insertion_point(field_get:S_Attack.Target)
  return _internal_target();
}
inline void S_Attack::set_target(::int32_t value) {
  _internal_set_target(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:S_Attack.Target)
}
inline ::int32_t S_Attack::_internal_target() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.target_;
}
inline void S_Attack::_internal_set_target(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_ = value;
}

// -------------------------------------------------------------------

// S_EnemyMove

// repeated .Enemy enemy = 1;
inline int S_EnemyMove::_internal_enemy_size() const {
  return _internal_enemy().size();
}
inline int S_EnemyMove::enemy_size() const {
  return _internal_enemy_size();
}
inline void S_EnemyMove::clear_enemy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enemy_.Clear();
}
inline ::Enemy* S_EnemyMove::mutable_enemy(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:S_EnemyMove.enemy)
  return _internal_mutable_enemy()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::Enemy>* S_EnemyMove::mutable_enemy()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:S_EnemyMove.enemy)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_enemy();
}
inline const ::Enemy& S_EnemyMove::enemy(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:S_EnemyMove.enemy)
  return _internal_enemy().Get(index);
}
inline ::Enemy* S_EnemyMove::add_enemy() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::Enemy* _add = _internal_mutable_enemy()->Add();
  // @@protoc_insertion_point(field_add:S_EnemyMove.enemy)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::Enemy>& S_EnemyMove::enemy() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:S_EnemyMove.enemy)
  return _internal_enemy();
}
inline const ::google::protobuf::RepeatedPtrField<::Enemy>&
S_EnemyMove::_internal_enemy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.enemy_;
}
inline ::google::protobuf::RepeatedPtrField<::Enemy>*
S_EnemyMove::_internal_mutable_enemy() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.enemy_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::MoveState> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::MoveState>() {
  return ::MoveState_descriptor();
}
template <>
struct is_proto_enum<::E_TYPE> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::E_TYPE>() {
  return ::E_TYPE_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_test_2eproto_2epb_2eh

# 소켓 입출력 함수

소켓 연결에 성공 했으니 데이터를 주고 받아보자

## send

인자는 4개가 있다.  
첫번째 인자는 전송 대상과의 연결을 의미하는 소켓의 핸들이다.  
두번쨰 인자는 전송할 데이터를 저장하는 버퍼의 주소 값이다.  
세번쨰 인자는 전송할 데이터의 바이트 길이이다.  
네번쨰 인자는 플래그 값이다. 비트 OR연산자를 이용해서 생성된다.

성공했다면 전송 된 총 바이트트 수를 반환한다. 꼭 len인자로 보낸 값과 같지는 않다.
실패시에는 SOCEKT_ERROR가 반환된다.

메시지 지향 소켓( AF_INET 또는 AF_INET6 주소 패밀리, SOCK_DGRAM 유형 및 IPPROTO_UDP  
프로토콜)의 경우 기본 공급자의 최대 패킷 크기를 초과하지 않도록 주의해한다.

한가지 주의 할 것은 전송 성공이 꼭 수신 성공까지 의미 하지 않음에 유의 해야한다.  
send의 완료시점은 전송 데이터가 뒤에서 후술할 송신버퍼로 복붙 완료시점이다.

윈속 공급자는 큰 송신 요청을 여러 전송으로 분할해서 보낼수 도 있다. 이로인해 동일한  
스트림 지향 소켓의 여러 동시 전송 요청시 데이터가 섞일 수 있으니 유의해야한다.

```c++
while (true)
{
	char sendBuf[100] = "Hello?";
	send(hSocket, sendBuf, 100, 0);
}
```

## recv

인자는 send와 같다.  
첫번째 인자는 수신 대상과의 연결을 의미하는 소켓의 핸들이다.  
두번쨰 인자는 수신한 데이터를 저장하는 버퍼의 주소 값이다.  
세번쨰 인자는 수신 가능한 바이트의 최대 길이이다.  
네번쨰 인자는 플래그 값이다. 비트 OR연산자를 이용해서 생성된다.

성공하면 수신된 바이트 수를 반환하고 실패시 SOCEKT_ERROR를 반환한다.
함수는 오로지 연결된 곳의 메시지만 반환하고 나머지는 버린다.
수신할 데이터가 없다면 블락된다.

```C++
recv(hSocket, recvBuf, 100, 0);
```

## 소켓 송수신 버퍼

TCP소켓에는 우리가 앱에서 만든 배열말고, 송신버퍼와 수신버퍼가 각각 존재한다.
소켓생성시에 자동생성되며 크기는 조절 가능하다.

소켓을 닫아도 수신버퍼에 남은 것은 계속 전송되고 송신버퍼에 있는 건 버려진다.

전송 시스템에서 송신할 데이터를 저장할 공간이 없다면 소켓이 블락 해제 모드가 아닌한  
송신이 블락된다.

#### 참조

- [MSDN : send](https://learn.microsoft.com/ko-kr/windows/win32/api/winsock2/nf-winsock2-send)
- [MSDN : recv](https://learn.microsoft.com/ko-kr/windows/win32/api/winsock2/nf-winsock2-recv)

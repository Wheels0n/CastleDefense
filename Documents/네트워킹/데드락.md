# 데드락

실무에서 nullptr에러와 함께 버그 대장(?)중 하나인 데드락을 살펴보자.

## 데드락

데드락(교착상태)는 두 스레드가 서로를 기다리는 상황을 의미한다. 예시를 보자

```c++
std::mutex g_m1;
std::mutex g_m2;
void Lock1()
{
	for (int i = 0; i < 1; ++i)
	{
		std::lock_guard<std::mutex> lockGuard1(g_m1);
		std::lock_guard<std::mutex> lockGuard2(g_m2);
	}
}
void Lock2()
{
	for (int i = 0; i < 1; ++i)
	{
		std::lock_guard<std::mutex> lockGuard2(g_m2);
		std::lock_guard<std::mutex> lockGuard1(g_m1);
	}
}


int main()
{
	std::thread t1(Lock1);
	std::thread t2(Lock2);
	t1.join();
	t2.join();

}
```

t1은 락1,2를 잡고 t2는 락2,1을 잡는다. 근데 두 스레드가 동시에 락을 잡아버리는 경우가  
발생한다. 그렇게 영원히 대기상태로 빠지게 된다.

순서를 1->2로 강제하면 해결은 된다. 허나 코드가 방대해지는데 순서를 다 예측하여 맞추는 건
불가능하다. 데드락은 100%예방 할 수 없다.

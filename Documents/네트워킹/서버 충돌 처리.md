# 서버 충돌 처리

AI 때문에 서버에서 내가 직접 구현할 게 많아졌다. 그중 하나가 충돌인데 공간분할을 해야 했고  
내가 선택한 방식은 Octree이다. 자식이 8개라 그렇다. Octree 이론 자체는 렌더러 폴더에 넣을 것이다.

적 공격 여부를 클라에서 판단하는 건 부정행위의 위험이있다. 또한 그냥 스폰할떄도 서버에서 감안 할 필요가 있다.  
그렇다고 클라에 충돌처리를 맡겨 버리면 클라마다 다르게 나올수있어서 서버에서 꼭 처리해 줘야한다.

## 구현

```c++
struct Octant : enable_shared_from_this<Octant>
{
	Octant(float  center[3], int len) :IsLeaf(TRUE), m_len(len)
	{
		aabb.center[0] = center[0];
		aabb.center[1] = center[1];
		aabb.center[2] = center[2];


		aabb.bmin[0] = center[0] + len;
		aabb.bmin[1] = center[1] + len;
		aabb.bmin[2] = center[2] + len;


		aabb.bmax[0] = center[0] - len;
		aabb.bmax[1] = center[1] - len;
		aabb.bmax[2] = center[2] - len;
	};

	//현 옥탄트 크기
	AABB	aabb;
	shared_ptr<Octant> child[8];
	list<AABB*> objects;
	int		m_len;
	BOOL	IsLeaf;
};


class Octree
{
private:
	//현재 노드의 바로 아래 자식만 생성
	void CreateNode(shared_ptr<Octant> pRoot, float center[3], int len);

		 Octree();
		 Octree(const Octree& obj) = delete;
public :
	//AABB를 받아 딱맞아 들어가는 노드 발견시 넣고 종료. 스폰/디스폰/이동시 호출
	//포함된 Octant 포인터 반환
	//AI/플레이어 이동전에 호출하여, 새 노드에 이미 무언가 있다면 그때 충돌 검사
	//충돌한다면 둘다 멈춤. AI는 새경로 갱신까지

	//TODO:서버는 입력만 받는 데 정확한 충돌 지점 계산이???

	shared_ptr<Octant> PlaceInNode(AABB*);
	//갱신시 현재노드로부터 제거
	void	RemoveFromNode(AABB*);

	static Octree& GetInstance()
	{
		static  Octree instance;
		return instance;
	}
private:
	shared_ptr<Octant> m_pRoot;
	RWLock				m_lock;
};
```

Octant는 옥트리의 노드로 보면된다. AABB로 포함 범위를 표현하고, 자식 노드, 포함하는 개체들, 리프노드 여부를 가진다.  
Octree는 루트 노드와 갱신 함수를 가진다. 처음에 미리 생성 해놓는 답시고 무지성으로 리프노드를 len==1까지 했다가 컴퓨터가 먹통이 되었다.... 생각해보니 노드의 깊이가 올라갈수록 octant수가 8배가 된다(8+64+512+...). 근데 깊이가 11이라, 최하층만 봐도 8589934592 바이트, 약 8기가다. 투사체 고려해서 최소 길이 1로 서버 실행시에 만들려 했는데 안된다. 실시간으로 최대 1\*8개의 노드를 만드는 수 밖에 없다. 메모리 풀로 88개의(길이 1까지 갈 경우) octant를 만들면 0.1ms 초가 나온다.

갱신할때 먼저 루트노드로부터 현 캐릭터(AI또는 플레이어)의 AABB로 탐색한다. 담을 수 없을 때까지 재귀적으로 탐색한다. 마지막으로 담는 게 가능했던 노드에서 현 AABB를 찾아서 지운다.

```c++
void Octree::RemoveFromNode(AABB* pAABB)
{
	shared_ptr<Octant> pRoot = m_pRoot;
	shared_ptr<Octant> pPre = nullptr;

	WriteLockGuard lockGuard(m_lock);
	if (!pRoot->IsLeaf)
	{
		for (int i = 0; i < 8; )
		{
			shared_ptr<Octant> pChild = pRoot->child[i];
			//담은 수 있는 octant나오면 결과값에 대입 및 i=0, 아니면 i++
			if (pChild->aabb.bmax[0] <= pAABB->bmax[0] && pChild->aabb.bmax[1] <= pAABB->bmax[1] && pChild->aabb.bmax[2] <= pAABB->bmax[2] &&
				pChild->aabb.bmin[0] >= pAABB->bmin[0] && pChild->aabb.bmin[1] >= pAABB->bmin[1] && pChild->aabb.bmin[2] >= pAABB->bmin[2])
			{
				pPre = pRoot;
				pRoot = pChild;
				if (pChild->IsLeaf)
				{
					break;
				}
				else
				{
					i = 0;
				}

			}
			else
			{
				++i;
			}
		}
	}



	for (auto it = pRoot->objects.begin(); it != pRoot->objects.end(); ++it)
	{
		if (*it == pAABB)
		{
			pRoot->objects.erase(it);
			break;
		}
	}

	if (pRoot->objects.empty())
	{
		pRoot=nullptr;
		if (pPre)
		{
			int nChild = 0;
			for (int i = 0; i < 8; ++i)
			{
				nChild = pPre->child[i] != nullptr ? nChild + 1 : nChild;
			}
			if (nChild == 0)
			{
				pPre->IsLeaf = true;
			}
		}
	}


	return;
}
```

마찬 가지로 삽입도 담는 게 가능한 노드를 재귀적으로 파악한다. 마지막으로 담는게 가능했던 노드의 기존 개체들과 AABB overlapp판정을
하여 충돌 여부를 판단한다.

```c++
shared_ptr<Octant> Octree::PlaceInNode(AABB* pAABB)
{
	shared_ptr<Octant> result = m_pRoot;
	WriteLockGuard lockGuard(m_lock);
	for (int i = 0; i < 8; )
	{
		if (result->IsLeaf)
		{
			CreateNode(result, result->aabb.center, result->m_len);
		}
		shared_ptr<Octant> pChild = result->child[i];
		//담은 수 있는 octant나오면 결과값에 대입 및 i=0, 아니면 i++
		//가져온 obj가 음의 방향으로만 증가함에 유의
		if (pChild->aabb.bmax[0] <= pAABB->bmax[0] && pChild->aabb.bmax[1] <= pAABB->bmax[1] && pChild->aabb.bmax[2] <= pAABB->bmax[2] &&
			pChild->aabb.bmin[0] >= pAABB->bmin[0] && pChild->aabb.bmin[1] >= pAABB->bmin[1] && pChild->aabb.bmin[2] >= pAABB->bmin[2])
		{
			result = pChild;
			i = 0;
		}
		else
		{
			i++;
		}
	}

	for (auto it = result->objects.begin(); it != result->objects.end(); ++it)
	{
		AABB* pObject = *it;
		if((pObject->bmax[0] < pAABB->bmin[0] && pObject->bmax[1] < pAABB->bmin[1] && pObject->bmax[2] < pAABB->bmin[2]&&
			pObject->bmin[0] > pAABB->bmax[0] && pObject->bmin[1] > pAABB->bmax[1] && pObject->bmin[2] > pAABB->bmax[2])
			||
			(pAABB->bmax[0] < pObject->bmin[0] && pAABB->bmax[1] < pObject->bmin[1] && pAABB->bmax[2] < pObject->bmin[2] &&
				pAABB->bmin[0] > pObject->bmax[0] && pAABB->bmin[1] > pObject->bmax[1] && pAABB->bmin[2] > pObject->bmax[2]))
		{
			cout << "Collision Detected\n";
		}

	}
	result->objects.push_back(pAABB);
}
```

언리얼에서 ue5 query와physics 활성, 커스텀 컬리전 프로파일을 만들었다. 그리고 캐릭터의 충돌 컴포넌트(캡슐)에 설정했다.
충돌이 제대로 판정된다. 이제껏 서버는 플레이어에게 단순히 전달만 했는 데 이제는 시뮬을 통해줘야한다.

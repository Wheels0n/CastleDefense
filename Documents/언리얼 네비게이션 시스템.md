# 언리얼 네비게이션 시스템

## 네비게이션 시스템

언리얼 엔진의 네비게이션 시스템은 AI 에이전트들이 레벨을 길찾기를 통해 navigate할 수 있게 해준다.  
시스템은 레벨의 collsion geometry로 부터 '네비게이션 메시'를 생성하고 이를 '타일'로 나눈다. 이 타일들은  
다시 폴리곤으로 나뉘어 에이전트가 목적지까지 이동할 때 쓰이는 그래프를 형성한다. 각 폴리곤은 최적의 경로를  
판단하기 위한 비용이 부여되어 있다.

네비게이션 다양한 컴포넌트와 시스템은 메시가 생성되는 방식에 대한 세팅이(Static, Dynamic, Dynamic Modifiers Only)  
있다.

### NavModifer컴포넌트

이 컴포넌트 자체는 아무것도 하지 않는 다. 다만 기본 형태(basic shape) 컴포넌트를 액터의 루트로 가지고 있다면  
루트 컴포턴트의 볼륨은 NavModifier 컴포넌트의 Area 클래스에 따라 내부의 네비 메시 생성을 수정 한다. 이 컴포넌트는
액터당 한 개만 가져야한다.

이 영역클래스들은 영역에 도달하는 비용 같은 기본적인 것이나, 웅크린상태에서 도달 가능하지 여부 같은 심도있는 것들을  
다룬다. 종류는 네 가지가 있다.

- NavArea_Default : 볼륨내에 영역과 네비게이션 메시에 동일한 비용을 부여한다.
- NavArea_LowHeight : 현 위치 보다 낮아서 이동 할 수 없는 영역을 나타낸다. 이 볼륨내에는 네비게이션 데이터를 생성
  하지 않는다.
- NavArea_Null: 볼륨내에 빈 공간을 나타낸다. 이 볼륨내에는 네비게이션 데이터를 생성하지 않는다.
- NavArea_Obstacle: 이 볼륨 내에 영역에 높은 비용을 부여한다.

또한 Navigation Query Filters통해 비용을 오버라이드 할 수 도 있다.

### 네비게이션 생성 모드

Static이 기본 값이다.

- Static : 오프라인 상태로 생성되어 레벨과 함께 저장 된다. 런타임에 불려지고 바뀌지 않는다.
- Dynamic : 오프라인 상태로 생성되어 레벨과 함께 저장 되거나 런타임에 형성 된다. 런타임에 네비게이션 관련 데이터가
  갱신 될 수 있으며 해당 데이터에 영향을 받은 타일에 생성이 실행 될 수 있다.
- Dynamic Modifiers Only : 오프라인 상태로 생성되어 레벨과 함께 저장 된다. 런타임에는 네비게이션 수정자들(네비게이션
  영역, 네비게이션 링크, 동적 개체)만이 막힌 공간이나, 비용의 변경으로 현 네비게이션 메시를 수정 할 수 있다. 어떠한  
  네비게이션 메시 표면도 런타임에는 생성 되지 않는다.

### 네비게이션 링크 프록시

네비게이션 프록시는 직접적인 네비게이션 경로를 가지지 않는 네비게이션 메시 내의 두영역을 이어 준다. 경로 탐색중에  
목적지에 도달 하기 위한 추가 연결로 사용된다.

역시나 언리얼 공식문서는 코드 자체 설명은 없고 기본 컨셉과 BP사용법만 가득했다.

## 코드

### 네비게이션 시스템 클래스와 생성 관련

우선 UNavigationSystemV1이라는 클래스가 있는데 이는 UNavigationSystemBase를 상속 받는다. 이 부모 클래스는
죄다 델리게이트로 가득 차있다.

```c++
//NavigationSystemBase.h
class UNavigationSystemBase : public UObject
```

```C++
//Engine.h
/** Sets the class to use for NavigationSystem, which can be overridden to change game-specific navigation/AI behavior. */
UPROPERTY()
TSubclassOf<class UNavigationSystemBase>  NavigationSystemClass;
```

각 월드는 네비게이션 시스템을 오브젝트 포인터로 들고 있다. 엔진에서 설정한 네비게이션 클래스로
새 네비게이션 시스템을 만든다.

```c++
//World.h
UNavigationSystemV1* UNavigationSystemV1::CreateNavigationSystem(UWorld* WorldOwner)
{
	UNavigationSystemV1* NavSys = NULL;

	// create navigation system for editor and server targets, but remove it from game clients
	if (WorldOwner && (*GEngine->NavigationSystemClass != nullptr)
		&& (GEngine->NavigationSystemClass->GetDefaultObject<UNavigationSystemV1>()->bAllowClientSideNavigation || WorldOwner->GetNetMode() != NM_Client))
	{
		AWorldSettings* WorldSettings = WorldOwner->GetWorldSettings();
		if (WorldSettings == NULL || WorldSettings->IsNavigationSystemEnabled())
		{
			NavSys = NewObject<UNavigationSystemV1>(WorldOwner, GEngine->NavigationSystemClass);
			WorldOwner->SetNavigationSystem(NavSys);
		}
	}

	return NavSys;
}

/** The world's navigation data manager */
UPROPERTY(Transient)
TObjectPtr<class UNavigationSystemBase>				NavigationSystem;

void UWorld::SetNavigationSystem(UNavigationSystemBase* InNavigationSystem)
{
	if (NavigationSystem != NULL && NavigationSystem != InNavigationSystem)
	{
		NavigationSystem->CleanUp(FNavigationSystem::ECleanupMode::CleanupWithWorld);
	}

	NavigationSystem = InNavigationSystem;
}
```

### UNavigationSystemV1

UNavigationSystemV1안을 보면 만들어질 타일들의 경계를 담고 있고 NavigationData를 담고있다.

```c++
//
/** Bounds of tiles to be built */
UPROPERTY(Transient)
FBox BuildBounds;

UPROPERTY(Transient)
TArray<TObjectPtr<ANavigationData>> NavDataSet;
```

그리고 에이전트 언급이 계속 나온다. 에이전트 별로 처리하는 느낌이 강하게 든다.

### 에이전트 별 데이터 생성

```c++
/** If not None indicates which of navigation datas and supported agents are
 * going to be used as the default ones. If navigation agent of this type does
 * not exist or is not enabled then the first available nav data will be used
 * as the default one */
UPROPERTY(config, EditAnywhere, BlueprintReadOnly, Category = Navigation)
FName DefaultAgentName;

/**
 * Looks for NavData generated for specified movement properties and returns it. NULL if not found;
 */
NAVIGATIONSYSTEM_API virtual ANavigationData* GetNavDataForProps(const FNavAgentProperties& AgentProperties);

/**
 * Looks for NavData generated for specified movement properties and returns it. NULL if not found; Const version.
 */
NAVIGATIONSYSTEM_API virtual const ANavigationData* GetNavDataForProps(const FNavAgentProperties& AgentProperties) const;

/** Goes through all registered NavigationData instances and retrieves the one
 *	supporting agent named AgentName */
NAVIGATIONSYSTEM_API virtual ANavigationData* GetNavDataForAgentName(const FName AgentName) const;
```

내비게이션 시스템의 빌드 함수에서 SpawnMissingNavigationData()를 호출 하는 데 이 함수에서 SupportedAgentsMask라는 FNavAgentSelector를 통해 포함여부를 먼저 판단한다.

```c++
/** NavigationSystem's properties in Project Settings define all possible supported agents,
 *	but a specific navigation system can choose to support only a subset of agents. Set via
 *	NavigationSystemConfig */
UPROPERTY(config, EditAnywhere, Category = Agents)
FNavAgentSelector SupportedAgentsMask;


void UNavigationSystemV1::Build()
{
	//...
	SpawnMissingNavigationData();
}

void UNavigationSystemV1::SpawnMissingNavigationData()
{
	const int32 AllSupportedAgentsCount = SupportedAgents.Num();
	check(AllSupportedAgentsCount >= 0);
	int32 ValidSupportedAgentsCount = 0;
	for (int32 AgentIndex = 0; AgentIndex < AllSupportedAgentsCount; ++AgentIndex)
	{
		if (SupportedAgentsMask.Contains(AgentIndex))
		{
			++ValidSupportedAgentsCount;
		}
	}
```

FNavAgentSelector는 공용체로 구성되어있고 비트연산 관련 함수들만 있다. 프로젝트 설정의  
네비게이션 시스템 속성에서 모든 지원 가능한 에이전트들을 정의한다.  
![프로젝트 세팅 - 에이전트](https://substackcdn.com/image/fetch/w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F30b495e2-0bab-41c7-9898-dd56e665b812_990x1010.png)

```c++
struct FNavAgentSelector
{
	GENERATED_USTRUCT_BODY()

	static const uint32 InitializedBit = 0x80000000;
	static const uint32 AllAgentsMask = 0x7fffffff;

#if CPP
	union
	{
		struct
		{
#endif
			UPROPERTY(EditAnywhere, Category = Default)
			uint32 bSupportsAgent0 : 1;
			UPROPERTY(EditAnywhere, Category = Default)
			uint32 bSupportsAgent1 : 1;
			UPROPERTY(EditAnywhere, Category = Default)
			uint32 bSupportsAgent2 : 1;
			UPROPERTY(EditAnywhere, Category = Default)
			uint32 bSupportsAgent3 : 1;
			UPROPERTY(EditAnywhere, Category = Default)
			uint32 bSupportsAgent4 : 1;
			UPROPERTY(EditAnywhere, Category = Default)
			uint32 bSupportsAgent5 : 1;
			UPROPERTY(EditAnywhere, Category = Default)
			uint32 bSupportsAgent6 : 1;
			UPROPERTY(EditAnywhere, Category = Default)
			uint32 bSupportsAgent7 : 1;
			UPROPERTY(EditAnywhere, Category = Default)
			uint32 bSupportsAgent8 : 1;
			UPROPERTY(EditAnywhere, Category = Default)
			uint32 bSupportsAgent9 : 1;
			UPROPERTY(EditAnywhere, Category = Default)
			uint32 bSupportsAgent10 : 1;
			UPROPERTY(EditAnywhere, Category = Default)
			uint32 bSupportsAgent11 : 1;
			UPROPERTY(EditAnywhere, Category = Default)
			uint32 bSupportsAgent12 : 1;
			UPROPERTY(EditAnywhere, Category = Default)
			uint32 bSupportsAgent13 : 1;
			UPROPERTY(EditAnywhere, Category = Default)
			uint32 bSupportsAgent14 : 1;
			UPROPERTY(EditAnywhere, Category = Default)
			uint32 bSupportsAgent15 : 1;
#if CPP
		};
		uint32 PackedBits;
	};
#endif

```

기존에 만들어진 네비게이션 데이터가 없다면 직접만든다.

```C++
	//UNavigationSystemV1::SpawnMissingNavigationData()
	// Bit array might be a bit of an overkill here, but this function will be called very rarely
	TBitArray<> AlreadyInstantiated;
	uint8 NumberFound = 0;

	// 1. check whether any of required navigation data has already been instantiated
	NumberFound = FillInstantiatedDataMask(AlreadyInstantiated);

	// 2. for any not already instantiated navigation data call creator functions
	if (NumberFound < ValidSupportedAgentsCount)
	{
		SpawnMissingNavigationDataInLevel(AlreadyInstantiated);
	}

	if (MainNavData == nullptr || MainNavData->IsPendingKillPending())
	{
		MainNavData = GetDefaultNavDataInstance(FNavigationSystem::DontCreate);
	}
}

```

여기서 에이전트별로 FNavDataConfig를 통해 네비게이션 데이터를 생성한다.

```c++
UPROPERTY(config, EditAnywhere, Category = Agents)
TArray<FNavDataConfig> SupportedAgents;


void UNavigationSystemV1::SpawnMissingNavigationDataInLevel(const TBitArray<>& InInstantiatedMask, ULevel* InLevel/*=nullptr*/)
{
	UWorld* NavWorld = GetWorld();

	ensure(SupportedAgents.Num() == InInstantiatedMask.Num());
	int32 AllSupportedAgentsCount = InInstantiatedMask.Num();

	for (int32 AgentIndex = 0; AgentIndex < AllSupportedAgentsCount; ++AgentIndex)
	{
		const FNavDataConfig& NavConfig = SupportedAgents[AgentIndex];
		if (InInstantiatedMask[AgentIndex] == false
			&& SupportedAgentsMask.Contains(AgentIndex)
			&& NavConfig.GetNavDataClass<ANavigationData>() != nullptr)
		{
```

FNavDataConfig은 에이전트의 이름, 에디터에서 표시할 색상, 크기등을 담고 있다.  
FNavAgentProperties를 상속하는 데 이 구조체도 에이전트의 크기, 관련 정보를 담고  
있다.

```c++
struct FNavDataConfig : public FNavAgentProperties
{
	GENERATED_USTRUCT_BODY()

	/** Internal/debug name of this agent */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Display)
	FName Name;

	/** Color used to represent this agent in the editor and for debugging */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Display)
	FColor Color;

	/** Rough size of this agent, used when projecting unto navigation mesh */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = Querying)
	FVector DefaultQueryExtent;

protected:
	/** Class to use when spawning navigation data instance */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Navigation, meta = (MetaClass = "/Script/NavigationSystem.NavigationData"))
	TSoftClassPtr<AActor> NavDataClass;

//NavigationType.h
struct FNavAgentProperties : public FMovementProperties
{
	GENERATED_USTRUCT_BODY()

	/** Radius of the capsule used for navigation/pathfinding. */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=MovementProperties, meta=(DisplayName="Nav Agent Radius"))
	float AgentRadius;

	/** Total height of the capsule used for navigation/pathfinding. */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=MovementProperties, meta=(DisplayName="Nav Agent Height"))
	float AgentHeight;

	/** Step height to use, or -1 for default value from navdata's config. */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=MovementProperties, meta=(DisplayName="Nav Agent Step Height"))
	float AgentStepHeight;
	//...
}
```

데이터 인스턴스를 만드는 데 컨픽과 이름 설정 말고는 하는 일이 없어 보인다.

```c++
//void UNavigationSystemV1::SpawnMissingNavigationDataInLevel(const TBitArray<>& InInstantiatedMask, ULevel* InLevel/*=nullptr*/)
			//...
			ANavigationData* Instance = CreateNavigationDataInstanceInLevel(NavConfig, InLevel);


ANavigationData* UNavigationSystemV1::CreateNavigationDataInstanceInLevel(const FNavDataConfig& NavConfig, ULevel* SpawnLevel)
{
	UWorld* World = GetWorld();
	check(World);

	const int32 NavSupportedAgents = GetSupportedAgentIndex(NavConfig);

	// not creating new NavData instance if the agent it's representing is not supported
	// with the exception of AbstractNavData
	if (NavSupportedAgents == INDEX_NONE
		&& NavConfig.GetNavDataClass<AAbstractNavData>() == nullptr)
	{
		UE_LOG(LogNavigation, Warning, TEXT("Unable to create NavigationData instance for config \'%s\' as this agent is not supported by current NavigationSystem instance")
			, *NavConfig.GetDescription());
		return nullptr;
	}

	FActorSpawnParameters SpawnInfo;
	SpawnInfo.OverrideLevel = SpawnLevel;
	if (bSpawnNavDataInNavBoundsLevel && SpawnLevel == nullptr && RegisteredNavBounds.Num() > 0)
	{
		// pick the first valid level that supports these agents
		for (const FNavigationBounds& Bounds : RegisteredNavBounds)
		{
			if (Bounds.SupportedAgents.Contains(NavSupportedAgents) && Bounds.Level.IsValid())
			{
				SpawnInfo.OverrideLevel = Bounds.Level.Get();
				break;
			}
		}
	}
	if (SpawnInfo.OverrideLevel == nullptr)
	{
		SpawnInfo.OverrideLevel = World->PersistentLevel;
	}

	ANavigationData* Instance = World->SpawnActor<ANavigationData>(*NavConfig.GetNavDataClass<ANavigationData>(), SpawnInfo);

	if (Instance != NULL)
	{
		Instance->SetConfig(NavConfig);
		if (NavConfig.Name != NAME_None)
		{
			FString StrName = FString::Printf(TEXT("%s-%s"), *(Instance->GetFName().GetPlainNameString()), *(NavConfig.Name.ToString()));
			// temporary solution to make sure we don't try to change name while there's already
			// an object with this name
			UObject* ExistingObject = StaticFindObject(/*Class=*/ NULL, Instance->GetOuter(), *StrName, true);
			while (ExistingObject != NULL)
			{
				ANavigationData* ExistingNavigationData = Cast<ANavigationData>(ExistingObject);
				if (ExistingNavigationData)
				{
					UnregisterNavData(ExistingNavigationData);
				}

				// Reset the existing object's name
				ExistingObject->Rename(NULL, NULL, REN_DontCreateRedirectors | REN_ForceGlobalUnique | REN_DoNotDirty | REN_NonTransactional | REN_ForceNoResetLoaders);
				// see if there's another one, it does happen when undo/redoing
				// nav instance deletion in the editor
				ExistingObject = StaticFindObject(/*Class=*/ NULL, Instance->GetOuter(), *StrName, true);
			}

			// Set descriptive name
			Instance->Rename(*StrName, NULL, REN_DoNotDirty | REN_ForceNoResetLoaders);
#if WITH_EDITOR
			if (World->WorldType == EWorldType::Editor)
			{
				FString ActorLabel = StrName;
				if (Instance->IsPackageExternal())
				{
					// When using external package, don't rely on actor's name to generate a label as it contains a unique actor identifier which obfuscates the label
					ActorLabel = FString::Printf(TEXT("%s-%s"), *(Instance->GetClass()->GetFName().GetPlainNameString()), *(NavConfig.Name.ToString()));
				}

				constexpr bool bMarkDirty = false;
				Instance->SetActorLabel(ActorLabel, bMarkDirty);
			}
#endif // WITH_EDITOR
		}
	}

	return Instance;
}
```

생성이 끝나면 네비게이션 데이터를 큐에 넣어 둔다.

```c++
//void UNavigationSystemV1::SpawnMissingNavigationDataInLevel(const TBitArray<>& InInstantiatedMask, ULevel* InLevel/*=nullptr*/)
			//...
			if (Instance)
			{
				RequestRegistrationDeferred(*Instance);
			}
			else
			{
				UE_LOG(LogNavigation, Warning, TEXT("Was not able to create navigation data for SupportedAgent[%d]: %s"), AgentIndex, *NavConfig.Name.ToString());
			}
		}
	}
}

void UNavigationSystemV1::RequestRegistrationDeferred(ANavigationData& NavData)
{
	FScopeLock RegistrationLock(&NavDataRegistrationSection);

	if (NavDataRegistrationQueue.Num() < REGISTRATION_QUEUE_SIZE)
	{
		NavDataRegistrationQueue.AddUnique(&NavData);
	}
	else
	{
		UE_LOG(LogNavigation, Warning, TEXT("Navigation System: registration queue full! System:%s NavData:%s"), *GetPathNameSafe(this), *GetPathNameSafe(&NavData));
	}
}
```

### 새로운 데이터를 등록

앞서 만든, 큐에서 등록 대기 중인 데이터들을 처리해야한다.

```c++
//void UNavigationSystemV1::Build()
//...
// make sure freshly created navigation instances are registered before we try to build them
ProcessRegistrationCandidates();



void UNavigationSystemV1::ProcessRegistrationCandidates()
{
	FScopeLock RegistrationLock(&NavDataRegistrationSection);

	if (NavDataRegistrationQueue.Num() == 0)
	{
		return;
	}

	const int CandidatesCount = NavDataRegistrationQueue.Num();
	int32 NumNavDataProcessed = 0;
	for (int32 CandidateIndex = CandidatesCount - 1; CandidateIndex >= 0; --CandidateIndex)
	{
		ANavigationData* NavDataPtr = NavDataRegistrationQueue[CandidateIndex];
		ULevel* OwningLevel = NavDataPtr != nullptr ? NavDataPtr->GetLevel() : nullptr;
		if (OwningLevel && OwningLevel->bIsVisible)
		{
			const ERegistrationResult Result = RegisterNavData(NavDataPtr);
			LogNavDataRegistrationResult(Result);

			if (Result != RegistrationSuccessful && Result != RegistrationFailed_DataPendingKill)
			{
				NavDataPtr->Destroy();
				if (NavDataPtr == MainNavData)
				{
					MainNavData = NULL;
				}
			}

			NumNavDataProcessed++;
			NavDataRegistrationQueue.RemoveAtSwap(CandidateIndex);
		}
	}
```

네비게이션 데이터 등록 함수에서 가지고 있던 컨픽을 등록, 해시등록, NavDataSet에 추가한다.

```c++
UNavigationSystemV1::ERegistrationResult UNavigationSystemV1::RegisterNavData(ANavigationData* NavData)
{
	//예외처리
			// check if this kind of agent has already its navigation implemented
		TWeakObjectPtr<ANavigationData>* NavDataForAgent = AgentToNavDataMap.Find(NavConfig);
		ANavigationData* NavDataInstanceForAgent = NavDataForAgent ? NavDataForAgent->Get() : nullptr;

		if (NavDataInstanceForAgent == nullptr)
		{
			// ok, so this navigation agent doesn't have its navmesh registered yet, but do we want to support it?
			bool bAgentSupported = false;

			for (int32 AgentIndex = 0; AgentIndex < SupportedAgents.Num(); ++AgentIndex)
			{
				if (NavData->GetClass() == SupportedAgents[AgentIndex].GetNavDataClass<ANavigationData>()
					&& SupportedAgents[AgentIndex].IsEquivalent(NavConfig) == true)
				{
					// it's supported, then just in case it's not a precise match (IsEquivalent succeeds with some precision)
					// update NavData with supported Agent
					bAgentSupported = true;

					NavData->SetConfig(SupportedAgents[AgentIndex]);
					AgentToNavDataMap.Add(SupportedAgents[AgentIndex], NavData);
					NavData->SetSupportsDefaultAgent(SupportedAgents[AgentIndex].Name == DefaultAgentName);
					NavData->ProcessNavAreas(ObjectPtrDecay(NavAreaClasses), AgentIndex);

					OnNavDataRegisteredEvent.Broadcast(NavData);

					NavDataSet.AddUnique(NavData);
					NavData->OnRegistered();

					break;
				}
			}
			Result = bAgentSupported == true ? RegistrationSuccessful : RegistrationFailed_AgentNotValid;
		}

}
```

등록이 끝나면 기본 네비게이션 인스턴스를 설정한다.

```c++
//void UNavigationSystemV1::ProcessRegistrationCandidates()
	if (NumNavDataProcessed)
	{
		MainNavData = GetDefaultNavDataInstance(FNavigationSystem::DontCreate);

		// See if any of registered navigation data now needs NavOctree
		if (DefaultOctreeController.IsValid() == false && RequiresNavOctree() == true)
		{
			ConditionalPopulateNavOctree();
		}
	}
}
```

### 리빌드

마지막으로 등록된 데이터들을 순회하면서 다시 만든다. 네비게이션 데이터를 만드는 과정을 훝어 보았다.

```c++
// and now iterate through all registered and just start building them
RebuildAll();

// Block until build is finished
for (ANavigationData* NavData : NavDataSet)
{
	if (NavData)
	{
		NavData->EnsureBuildCompletion();
	}
}

void UNavigationSystemV1::RebuildAll(bool bIsLoadTime)
{
	UE_LOG(LogNavigation, Verbose, TEXT("UNavigationSystemV1::RebuildAll"));

	const bool bIsInGame = GetWorld()->IsGameWorld();

	GatherNavigationBounds();

	// make sure that octree is up to date
	FNavigationDataHandler NavHandler(DefaultOctreeController, DefaultDirtyAreasController);
	NavHandler.ProcessPendingOctreeUpdates();

	PendingNavBoundsUpdates.Reset();

	DefaultDirtyAreasController.Reset();

	for (int32 NavDataIndex = 0; NavDataIndex < NavDataSet.Num(); ++NavDataIndex)
	{
		ANavigationData* NavData = NavDataSet[NavDataIndex];

		if (NavData && (!bIsLoadTime || NavData->NeedsRebuildOnLoad()) && (!bIsInGame || NavData->SupportsRuntimeGeneration()) && (BuildBounds.IsValid == 0))
		{
			UE_LOG(LogNavigationDataBuild, Display, TEXT("   RebuildAll building NavData:  %s."), *NavData->GetConfig().GetDescription());
			UE_LOG(LogNavigationDataBuild, Verbose, TEXT("   RebuildAll bIsLoadTime=%s, NavData->NeedsRebuildOnLoad()=%s, bIsInGame=%s, NavData->SupportsRuntimeGeneration()=%s, BuildBounds.IsValid=%s"),
				*LexToString(bIsLoadTime), *LexToString(NavData->NeedsRebuildOnLoad()), *LexToString(bIsInGame), *LexToString(NavData->SupportsRuntimeGeneration()), *LexToString(BuildBounds.IsValid));

#if	WITH_EDITOR
			NavData->SetIsBuildingOnLoad(bIsLoadTime);
#endif
			NavData->RebuildAll();
		}
	}
}
```

## ANavigationData

네비게이션 데이터 클래스는 자체는 담고있는 게 외부에 보여질 렌더링 컴포넌트와, 에이전트를 설명하는 navDataConfig있다. 그리고 이와
관련된 각종 setter/getter, 생명주기 관리 함수들, 그리고 길찾기 관련 함수들이 있다.

```c++
class ANavigationData : public AActor, public INavigationDataInterface
{
	//...
	UPROPERTY(transient, duplicatetransient)
	TObjectPtr<UPrimitiveComponent> RenderingComp;

protected:
	UPROPERTY()
	FNavDataConfig NavDataConfig;
}
```

근데 눈에 띄는 게 하나 있었다 NavDataGenerator다. 네비게이션 시스템에서 Rebuild()함수를 호출 할때 이 함수가 불린다.  
여기서 이제 제네레이터가 데이터를 생성한다.

```c++
//...
TSharedPtr<FNavDataGenerator, ESPMode::ThreadSafe> NavDataGenerator;

void ANavigationData::RebuildAll()
{
	const double LoadTime = FPlatformTime::Seconds();
	LoadBeforeGeneratorRebuild();
	FAssetCompilingManager::Get().FinishAllCompilation();
	UE_LOG(LogNavigationDataBuild, Display, TEXT("   %s load time: %.2fs"), ANSI_TO_TCHAR(__FUNCTION__), (FPlatformTime::Seconds() - LoadTime));

	ConditionalConstructGenerator(); //recreate generator

	if (NavDataGenerator.IsValid())
	{
#if WITH_EDITOR
		if (!IsBuildingOnLoad())
		{
			MarkPackageDirty();
		}
#endif // WITH_EDITOR

		NavDataGenerator->RebuildAll();
	}
}
```

근데 FNavDataGenerator는 가상함수로 가득하다. 정황상 비동기로 태스크 단위로 뭔가를 만드는 걸 추측 할 수 있다.

```c++
class FNavDataGenerator : public TSharedFromThis<FNavDataGenerator, ESPMode::ThreadSafe>
{
public:
	virtual ~FNavDataGenerator() {}

	/** Rebuilds all known navigation data */
	virtual bool RebuildAll() { return false; };

	/** Blocks until build is complete */
	virtual void EnsureBuildCompletion() {};

	/** Cancels build, may block until current running async tasks are finished */
	virtual void CancelBuild() {};

	/** Ticks navigation build
	 *  If the generator is set to time sliced rebuild then this function will only get called when
	 *  there is sufficient time (effectively roughly once in n frames where n is the number of time sliced nav data / generators currently building)
	 */
	virtual void TickAsyncBuild(float DeltaSeconds) {};

	/**  */
	virtual void OnNavigationBoundsChanged() {};

	/** Asks generator to update navigation affected by DirtyAreas */
	virtual void RebuildDirtyAreas(const TArray<FNavigationDirtyArea>& DirtyAreas) {}

	/** determines whether this generator is performing navigation building actions at the moment, dirty areas are also checked */
	virtual bool IsBuildInProgressCheckDirty() const { return false; }

	virtual bool GetTimeSliceData(int32& OutNumRemainingBuildTasks, double& OutCurrentBuildTaskDuration) const { OutNumRemainingBuildTasks = 0; OutCurrentBuildTaskDuration = 0.; return false; }

	/** Returns number of remaining tasks till build is complete
	 */
	virtual int32 GetNumRemaningBuildTasks() const { return 0; };

	/** Returns number of currently running tasks
	 */
	virtual int32 GetNumRunningBuildTasks() const { return 0; };

	//----------------------------------------------------------------------//
	// debug
	//----------------------------------------------------------------------//
	virtual uint32 LogMemUsed() const { return 0; }

#if ENABLE_VISUAL_LOG
	virtual void ExportNavigationData(const FString& FileName) const {}
	virtual void GrabDebugSnapshot(struct FVisualLogEntry* Snapshot, const FBox& BoundingBox, const FName& CategoryName, ELogVerbosity::Type Verbosity) const {}
#endif
};
```

### ARecastMesh

UNavigationSystemV1의 생성자에서 기본 네비게이션 데이터로 ARecastNavMesh로 설정한 걸 알 수있다. NavigationSystem.cpp파일에서도 데이터를  
ARecastNavMesh로 캐스팅하는 구문이 계속나온다. FNavDataConfig에서도 네비게이션 데이터 클래스를 들고 있다.

```c++
#if WITH_RECAST
			UNavigationSystemBase::GetDefaultNavDataClassDelegate().BindLambda([]() { return ARecastNavMesh::StaticClass(); });
#endif // WITH_RECAST
```

언리얼에서 기본으로 ARecastNavMesh를 네비게이션 데이터 클래스로 지정하는 데 Recast라는 접두어는 언리얼에서 Recate&Detour라는 lib을 사용했기에  
붙은 것이다. 진짜 무슨 원리로 네비게이션 메시를 만드는 지는 이 라이브러리의 영역이니 참조로만 남겨두었다.

네비게이션 데이터를 상속받는다. 타일, 셀들에 대한 인자등을 들고 있고 대부분이 경로 찾기나, 메시 관련 데이터에 대한 Getter들이다.

```c++
class ARecastNavMesh : public ANavigationData
{
	//..
	/** Retrieves the vertices for the specified polygon. Returns false on error. */
	NAVIGATIONSYSTEM_API bool GetPolyVerts(NavNodeRef PolyID, TArray<FVector>& OutVerts) const;
}
```

이제 끝인가 싶었는데 모든 함수는 또다른 Impl이라는 구현체 클래스를 통한다. 생성자를 보면 구현체 클래스를 인스턴스화 하고 있다.  
그리고 FRecastNavMeshGenerator라는 클래스를 해당 클래스에서 사용한다.

```c++
//ARecastNavMesh::ARecastNavMesh
	if (HasAnyFlags(RF_ClassDefaultObject) == false)
	{
		INC_DWORD_STAT_BY( STAT_NavigationMemory, sizeof(*this) );

		FindPathImplementation = FindPath;
		FindHierarchicalPathImplementation = FindPath;

		TestPathImplementation = TestPath;
		TestHierarchicalPathImplementation = TestHierarchicalPath;

		RaycastImplementation = NavMeshRaycast;

		RecastNavMeshImpl = new FPImplRecastNavMesh(this);

		// add predefined areas up front
		SupportedAreas.Add(FSupportedAreaData(UNavArea_Null::StaticClass(), RECAST_NULL_AREA));
		SupportedAreas.Add(FSupportedAreaData(UNavArea_LowHeight::StaticClass(), RECAST_LOW_AREA));
		SupportedAreas.Add(FSupportedAreaData(UNavArea_Default::StaticClass(), RECAST_DEFAULT_AREA));
	}
//...
bool ARecastNavMesh::GetPolyCenter(NavNodeRef PolyID, FVector& OutCenter) const
{
	return RecastNavMeshImpl && RecastNavMeshImpl->GetPolyCenter(PolyID, OutCenter);
}

bool ARecastNavMesh::GetPolyVerts(NavNodeRef PolyID, TArray<FVector>& OutVerts) const
{
	return RecastNavMeshImpl && RecastNavMeshImpl->GetPolyVerts(PolyID, OutVerts);
}

bool ARecastNavMesh::GetRandomPointInPoly(NavNodeRef PolyID, FVector& OutPoint) const
{
	return RecastNavMeshImpl && RecastNavMeshImpl->GetRandomPointInPoly(PolyID, OutPoint);
}
```

#### 참조

- [언리얼 공식 문서 : Navigation System ](https://dev.epicgames.com/documentation/en-us/unreal-engine/navigation-system-in-unreal-engine?application_version=5.4)
- [언리얼 공식 문서 : Modifying the Navigation Mesh](https://dev.epicgames.com/documentation/en-us/unreal-engine/overview-of-how-to-modify-the-navigation-mesh-in-unreal-engine?application_version=5.4)
- [언리얼 공식 문서 : Custom Navigation Areas and Query Filters](https://dev.epicgames.com/documentation/en-us/unreal-engine/overview-of-custom-navigation-areas-and-query-filters-in-unreal-engine?application_version=5.4)
- [Recast & Detour](https://www.unrealdoc.com/p/navigation-mesh)
- [Static NavMesh Generation](https://www.unrealdoc.com/p/navigation-mesh-static-gen)
- [AI Navigation in C++, Customize Path Following Every Tick](https://unrealcommunity.wiki/6100e80a9c9d1a89e0c2ec49)
